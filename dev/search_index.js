var documenterSearchIndex = {"docs":
[{"location":"guide/#Practical-Guide","page":"Theoretical Guide","title":"Practical Guide","text":"This guide covers model selection, interpretation of results, and practical applications for antibody sequence analysis.","category":"section"},{"location":"guide/#Model-Selection","page":"Theoretical Guide","title":"Model Selection","text":"","category":"section"},{"location":"guide/#DNA-Models","page":"Theoretical Guide","title":"DNA Models","text":"","category":"section"},{"location":"guide/#JC69-(Jukes-Cantor-1969)","page":"Theoretical Guide","title":"JC69 (Jukes-Cantor 1969)","text":"The simplest nucleotide substitution model with equal rates between all bases and uniform base frequencies (Ï€ = 0.25 for all).\n\nUse when:\n\nQuick distance estimates are needed\nSequences are closely related (low divergence)\nBase composition is approximately uniform\n\nmodel = create_model(JC69Model, 1.0, normalize=true)","category":"section"},{"location":"guide/#HKY85-(Hasegawa-Kishino-Yano-1985)","page":"Theoretical Guide","title":"HKY85 (Hasegawa-Kishino-Yano 1985)","text":"Extends JC69 with a transition/transversion rate ratio (Îº) and arbitrary base frequencies.\n\nUse when:\n\nTransition bias is expected (common in most biological data)\nBase frequencies differ from uniform\nAnalyzing somatic hypermutation in antibodies (Îº â‰ˆ 2-3 captures AID bias)\n\nÏ€ = [0.25, 0.25, 0.25, 0.25]  # A, C, G, T frequencies\nÎº = 2.5  # Transition/transversion ratio\nmodel = create_model(HKY85Model, 1.0, Ï€, Îº, normalize=true)","category":"section"},{"location":"guide/#GTR-(General-Time-Reversible)","page":"Theoretical Guide","title":"GTR (General Time-Reversible)","text":"The most general neutral, reversible model with 6 exchangeability parameters and arbitrary base frequencies.\n\nUse when:\n\nFull flexibility is required\nModel selection indicates simpler models are inadequate\nSufficient data exists to estimate additional parameters\n\nÏ€ = [0.3, 0.2, 0.2, 0.3]\nrates = [0.0 1.0 2.0 1.0;\n         1.0 0.0 1.0 2.0;\n         2.0 1.0 0.0 1.0;\n         1.0 2.0 1.0 0.0]\nmodel = create_model(GTRModel, 1.0, Ï€, rates, normalize=true)","category":"section"},{"location":"guide/#Protein-Models","page":"Theoretical Guide","title":"Protein Models","text":"","category":"section"},{"location":"guide/#LG-(Le-Gascuel-2008)","page":"Theoretical Guide","title":"LG (Le-Gascuel 2008)","text":"Empirical amino acid substitution matrix derived from 3,912 protein families. Generally the recommended default for protein sequence analysis.\n\nUse when:\n\nAnalyzing protein sequences (default choice)\nAntibody VH/VL region analysis\nGeneral protein evolution studies\n\nmodel = create_model(LGModel, 1.0, normalize=true)","category":"section"},{"location":"guide/#WAG-(Whelan-Goldman-2001)","page":"Theoretical Guide","title":"WAG (Whelan-Goldman 2001)","text":"Earlier empirical matrix from 182 protein families. Provides an alternative to LG with slightly different exchangeabilities.\n\nUse when:\n\nAlternative to LG for comparison\nConsistency with older analyses that used WAG\n\nmodel = create_model(WAGModel, 1.0, normalize=true)","category":"section"},{"location":"guide/#Recommended-Defaults","page":"Theoretical Guide","title":"Recommended Defaults","text":"Data Type Model Configuration\nProtein (simple) LG create_model(LGModel, 1.0, normalize=true)\nProtein (rate variation) LG+G create_gamma_model(base_lg, 1.0)\nAntibodies LG+G or Partition See Antibody section\nDNA (general) HKY85 create_model(HKY85Model, 1.0, Ï€, 2.0, normalize=true)\nDNA (quick estimate) JC69 create_model(JC69Model, 1.0, normalize=true)\n\n","category":"section"},{"location":"guide/#Understanding-Distances","page":"Theoretical Guide","title":"Understanding Distances","text":"","category":"section"},{"location":"guide/#Normalized-vs-Unnormalized-Models","page":"Theoretical Guide","title":"Normalized vs Unnormalized Models","text":"The normalize=true option scales the rate matrix so that the expected number of substitutions per unit time equals 1. This makes distances directly interpretable.\n\n# Normalized: distance = expected substitutions per site\nmodel = create_model(LGModel, 1.0, normalize=true)\n\n# Verify normalization\nrate = expected_substitution_rate(model.Q, model.Ï€)  # â‰ˆ 1.0\n\nWith normalization: A distance of 0.1 means approximately 10% of sites have experienced at least one substitution.\n\nWithout normalization: Distances depend on the model's inherent scaling and cannot be directly compared across models.","category":"section"},{"location":"guide/#Distance-Interpretation","page":"Theoretical Guide","title":"Distance Interpretation","text":"Distance Sequence Divergence Typical Scenario\n0.00-0.01 Nearly identical Recent duplication, sequencing of same clone\n0.01-0.05 Low divergence Closely related sequences, early divergence\n0.05-0.15 Moderate divergence Typical within-species variation\n0.15-0.50 High divergence Between-species comparisons\n>0.50 Saturated Multiple substitutions obscure signal","category":"section"},{"location":"guide/#Handling-Saturated-Sequences","page":"Theoretical Guide","title":"Handling Saturated Sequences","text":"For highly divergent sequences (p-distance > 0.7), distance estimates become unreliable due to multiple substitutions at the same site. Consider:\n\nUsing protein sequences instead of DNA (larger alphabet reduces saturation)\nFocusing on conserved regions\nInterpreting distances with caution\n\n","category":"section"},{"location":"guide/#Antibody-Sequence-Analysis","page":"Theoretical Guide","title":"Antibody Sequence Analysis","text":"","category":"section"},{"location":"guide/#Recommended-Models-for-Antibodies","page":"Theoretical Guide","title":"Recommended Models for Antibodies","text":"For antibody sequences, we recommend using rate variation models since CDR and framework regions evolve at very different rates. Full details, parameter guidance, and when to use +G vs partition: Advanced Models.\n\n# Option 1: LG+G (simplest, good default)\nbase = create_model(LGModel, 1.0, normalize=true)\nmodel = create_gamma_model(base, 0.8)  # Î±=0.8 captures CDR/FR heterogeneity\n\n# Option 2: Partition model (if you know CDR boundaries)\nframework = create_model(LGModel, 1.0, normalize=true)\ncdr = create_model(LGModel, 2.5, normalize=true)  # CDRs evolve faster\nmodel = create_partition_model(\n    1:26 => framework, 27:38 => cdr,      # FR1, CDR1\n    39:55 => framework, 56:65 => cdr,     # FR2, CDR2\n    66:104 => framework, 105:117 => cdr,  # FR3, CDR3\n    118:128 => framework                   # FR4\n)","category":"section"},{"location":"guide/#Measuring-Somatic-Hypermutation","page":"Theoretical Guide","title":"Measuring Somatic Hypermutation","text":"Evolutionary distance between germline and mutated antibody sequences quantifies the extent of somatic hypermutation (SHM).\n\nusing EvolutionModels\nusing BioSequences\nusing Optim\n\n# Use Gamma model for better handling of rate variation\nbase = create_model(LGModel, 1.0, normalize=true)\nmodel = create_gamma_model(base, 1.0)\n\ngermline = aa\"EVQLVESGGGLVQPGGSLRLSCAASGFTFSSYAMSWVRQAPGKGLEWVSAISGSGGSTYYADSVKGRFTISRDNSKNTLYLQMNSLRAEDTAVYYCAK\"\nmutated  = aa\"EVQLVESGGGLVQPGRSLRLSCAASGFTFSSYWMSWVRQAPGKGLEWVANIKQDGSEKYYVDSVKGRFTISRDNAKNSLYLQMNSLRAEDTAVYYCAK\"\n\n# Maximum likelihood distance estimation\nneg_ll(t) = t < 0 ? Inf : -sequence_likelihood(model, germline, mutated, t)\nresult = optimize(neg_ll, 0.0, 1.0, Brent())\ndistance = Optim.minimizer(result)\n\nprintln(\"SHM distance: $(round(distance, digits=4))\")","category":"section"},{"location":"guide/#SHM-Distance-Interpretation","page":"Theoretical Guide","title":"SHM Distance Interpretation","text":"Distance SHM Level Biological Context\n0.00-0.02 Minimal Near-germline, naive B cell\n0.02-0.05 Low Early memory, limited affinity maturation\n0.05-0.10 Moderate Typical memory B cell\n0.10-0.15 High Extensively matured, long-lived plasma cell\n>0.15 Very high Chronic infection, autoimmune conditions","category":"section"},{"location":"guide/#B-Cell-Lineage-Analysis","page":"Theoretical Guide","title":"B Cell Lineage Analysis","text":"Computing pairwise distances for clonally-related sequences enables lineage reconstruction and subclone identification.\n\nusing EvolutionModels\nusing FASTX\nusing Optim\n\n# Load aligned sequences from a B cell lineage\naln = read_alignment(\"bcell_lineage.fasta\")\n\nmodel = create_model(LGModel, 1.0, normalize=true)\nresult = compute_distances(model, aln)\n\n# Distance matrix for downstream analysis\nD = result.distances\nlabels = result.labels\n\nprint_distance_matrix(result, digits=3)\n\nThe resulting distance matrix can be used for:\n\nHierarchical clustering to identify subclones\nInput to tree reconstruction algorithms\nQuantifying within-lineage diversity","category":"section"},{"location":"guide/#DNA-Level-Analysis","page":"Theoretical Guide","title":"DNA-Level Analysis","text":"For nucleotide-level analysis capturing SHM transition bias:\n\nusing EvolutionModels\nusing BioSequences\n\n# HKY85 with transition bias typical of AID-mediated SHM\nÏ€ = [0.25, 0.25, 0.25, 0.25]\nÎº = 2.5  # Transitions favored over transversions\nmodel = create_model(HKY85Model, 1.0, Ï€, Îº, normalize=true)\n\ngermline_nt = dna\"GAGGTGCAGCTGGTGGAGTCTGGGGGAGGCTTGGTACAG\"\nmutated_nt  = dna\"GAGGTGCAGCTGGTGGAGTCTGGGGGAGGCTTGGTGCAG\"\n\n# Compute likelihood at estimated distance\ndistance = 0.05\nll = sequence_likelihood(model, germline_nt, mutated_nt, distance)","category":"section"},{"location":"guide/#Simulating-Sequence-Evolution","page":"Theoretical Guide","title":"Simulating Sequence Evolution","text":"Generate hypothetical evolved sequences for method validation or hypothesis testing:\n\nusing EvolutionModels\nusing BioSequences\nusing Random\n\nRandom.seed!(42)\n\nmodel = create_model(LGModel, 1.0, normalize=true)\ngermline = aa\"EVQLVESGGGLVQPGGSLRLSCAASGFTFSSYAMSWVRQAPGKGLEWVSAISGSGGSTYYADSVKGRFTISRDNSKNTLYLQMNSLRAEDTAVYYCAK\"\n\n# Simulate evolution at different distances\nfor t in [0.02, 0.05, 0.10, 0.15]\n    evolved = evolve_sequence(model, germline, t)\n    n_mut = count(g != e for (g, e) in zip(germline, evolved))\n    println(\"t=$t: $n_mut mutations ($(round(100*n_mut/length(germline), digits=1))%)\")\nend\n\n","category":"section"},{"location":"guide/#Likelihood-Computation","page":"Theoretical Guide","title":"Likelihood Computation","text":"","category":"section"},{"location":"guide/#Conditional-vs-Joint-Likelihood","page":"Theoretical Guide","title":"Conditional vs Joint Likelihood","text":"The sequence_likelihood function supports two modes:\n\nConditional likelihood (default):\n\nlog P(textseq2  textseq1 t) = sum_k=1^L log P(t)_x_1k x_2k\n\nJoint likelihood (joint=true):\n\nlog P(textseq1 textseq2  t) = sum_k=1^L left log pi_x_1k + log P(t)_x_1k x_2k right\n\nmodel = create_model(LGModel, 1.0, normalize=true)\nseq1 = aa\"EVQLVESGGGLVQPGGSLRL\"\nseq2 = aa\"EVQLVESGGGLIQPGGSLRL\"\n\n# Conditional: P(seq2 | seq1, t)\nL_cond = sequence_likelihood(model, seq1, seq2, 0.05)\n\n# Joint: P(seq1, seq2 | t)  \nL_joint = sequence_likelihood(model, seq1, seq2, 0.05, joint=true)","category":"section"},{"location":"guide/#When-Joint-Likelihood-Matters","page":"Theoretical Guide","title":"When Joint Likelihood Matters","text":"","category":"section"},{"location":"guide/#Use-Conditional-(default)-When:","page":"Theoretical Guide","title":"Use Conditional (default) When:","text":"Estimating evolutionary distance between two sequences\n\nThe stationary frequency term âˆ‘ log(Ï€áµ¢) is constant for fixed sequences regardless of t. Therefore, finding the distance that maximizes likelihood gives the same answer whether you use conditional or joint:\n\n# Both give the same optimal distance\nargmax_t P(seq2|seq1,t) = argmax_t P(seq1,seq2|t)\n\nFor distance estimation, conditional is computationally simpler and equally correct.\n\nComparing likelihoods at different times for the same sequence pair\n\nIf you're asking \"is t=0.05 or t=0.10 more likely for these sequences?\", the Ï€ term cancels out in the comparison.","category":"section"},{"location":"guide/#Use-Joint-Likelihood-When:","page":"Theoretical Guide","title":"Use Joint Likelihood When:","text":"Comparing different models\n\nWhen comparing models with different stationary frequencies (e.g., LG vs WAG, or models with estimated Ï€), the joint likelihood is required for proper comparison:\n\nmodel_lg = create_model(LGModel, 1.0, normalize=true)\nmodel_wag = create_model(WAGModel, 1.0, normalize=true)\n\n# WRONG: Conditional doesn't account for different Ï€\nL_lg_cond = sequence_likelihood(model_lg, seq1, seq2, 0.1)\nL_wag_cond = sequence_likelihood(model_wag, seq1, seq2, 0.1)\n\n# CORRECT: Joint includes Ï€ contribution\nL_lg_joint = sequence_likelihood(model_lg, seq1, seq2, 0.1, joint=true)\nL_wag_joint = sequence_likelihood(model_wag, seq1, seq2, 0.1, joint=true)\n\n# Model with higher joint likelihood better explains the data\nbetter_model = L_lg_joint > L_wag_joint ? \"LG\" : \"WAG\"\n\nComputing AIC/BIC for model selection\n\nInformation criteria require the actual likelihood, not conditional probability:\n\n# AIC = 2k - 2ln(L) where L is the likelihood\nk = 1  # number of parameters (just distance for empirical models)\nAIC_lg = 2*k - 2*L_lg_joint\nAIC_wag = 2*k - 2*L_wag_joint\n\nBayesian inference\n\nPosterior probabilities require the joint likelihood:\n\n# P(model|data) âˆ P(data|model) Ã— P(model)\n# P(data|model) is the joint likelihood\n\nComparing sequences with different compositions\n\nIf comparing likelihood across different sequence pairs, joint likelihood accounts for how \"probable\" each sequence is under the model's equilibrium:\n\n# Sequence pair A (common amino acids)\nseq1a = aa\"AAAAAAAAA\"\nseq2a = aa\"AAAAAAAAA\"\n\n# Sequence pair B (rare amino acids)  \nseq1b = aa\"WWWWWWWWW\"\nseq2b = aa\"WWWWWWWWW\"\n\n# Conditional treats both equally (identical sequences)\nL_a_cond = sequence_likelihood(model, seq1a, seq2a, 0.01)  # High\nL_b_cond = sequence_likelihood(model, seq1b, seq2b, 0.01)  # High\n\n# Joint reflects that W is rare in natural proteins\nL_a_joint = sequence_likelihood(model, seq1a, seq2a, 0.01, joint=true)\nL_b_joint = sequence_likelihood(model, seq1b, seq2b, 0.01, joint=true)\n# L_a_joint > L_b_joint because A is more common than W","category":"section"},{"location":"guide/#Lineage-Reconstruction-and-Clustering","page":"Theoretical Guide","title":"Lineage Reconstruction and Clustering","text":"For B cell lineage reconstruction or antibody clustering, use conditional likelihood (the default). This is what compute_distances() does internally.\n\nWhen computing pairwise distances for a distance matrix:\n\nEach pair gets its own ML distance estimate\nThe Ï€ term doesn't affect which distance is optimal for each pair\nAll distances are in the same units and directly comparable\n\n# Correct approach for lineage/clustering\nmodel = create_model(LGModel, 1.0, normalize=true)\nresult = compute_distances(model, alignment)\nD = result.distances  # Ready for tree building or clustering","category":"section"},{"location":"guide/#Comparing-Models-for-a-Lineage","page":"Theoretical Guide","title":"Comparing Models for a Lineage","text":"If you want to ask \"does LG or WAG better explain my antibody lineage?\", use alignment_likelihood to compute total likelihood over all pairs:\n\nusing EvolutionModels\nusing FASTX\nusing Optim\n\naln = read_alignment(\"lineage.fasta\")\n\nmodel_lg = create_model(LGModel, 1.0, normalize=true)\nmodel_wag = create_model(WAGModel, 1.0, normalize=true)\n\n# Compute total joint log-likelihood for each model\nresult_lg = alignment_likelihood(model_lg, aln)\nresult_wag = alignment_likelihood(model_wag, aln)\n\nprintln(\"LG:  total=$(round(result_lg.total_logL, digits=2)), mean=$(round(result_lg.mean_logL, digits=2))\")\nprintln(\"WAG: total=$(round(result_wag.total_logL, digits=2)), mean=$(round(result_wag.mean_logL, digits=2))\")\nprintln(\"Better model: \", result_lg.total_logL > result_wag.total_logL ? \"LG\" : \"WAG\")\n\nThis answers \"which substitution model better captures the evolutionary patterns in my antibody data?\" - useful when you have lineage-specific amino acid preferences or want to validate model choice.","category":"section"},{"location":"guide/#Summary","page":"Theoretical Guide","title":"Summary","text":"Question Use Reason\n\"What is the evolutionary distance?\" Conditional Ï€ doesn't affect optimal t\n\"Distance matrix for clustering/trees?\" Conditional Each pair optimized independently\n\"Which model fits better?\" Joint Must account for different Ï€\n\"Is this sequence pair unusual?\" Joint Accounts for amino acid frequencies\n\"What's the AIC/BIC?\" Joint Information criteria need true likelihood\n\"Posterior probability of model?\" Joint Bayesian inference requirement","category":"section"},{"location":"guide/#Maximum-Likelihood-Distance-Estimation","page":"Theoretical Guide","title":"Maximum Likelihood Distance Estimation","text":"Find the evolutionary distance that maximizes the likelihood:\n\nusing Optim\n\nmodel = create_model(LGModel, 1.0, normalize=true)\nseq1 = aa\"EVQLVESGGGLVQPGGSLRL\"\nseq2 = aa\"EVQLVESGGGLIQPGGSLRL\"\n\nneg_ll(t) = t < 0 ? Inf : -sequence_likelihood(model, seq1, seq2, t)\nresult = optimize(neg_ll, 0.0, 2.0, Brent())\n\nml_distance = Optim.minimizer(result)\nmax_logL = -Optim.minimum(result)","category":"section"},{"location":"guide/#Comparing-Evolutionary-Hypotheses","page":"Theoretical Guide","title":"Comparing Evolutionary Hypotheses","text":"Use likelihood ratios to compare different evolutionary scenarios:\n\nmodel = create_model(LGModel, 1.0, normalize=true)\n\n# Two sequences\nseqA = aa\"EVQLVESGGGLVQPGGSLRL\"\nseqB = aa\"EVQLVESGGGLIQPGGSLRL\"\n\n# Compare hypotheses: recent vs ancient divergence\nL_recent = sequence_likelihood(model, seqA, seqB, 0.02)\nL_ancient = sequence_likelihood(model, seqA, seqB, 0.20)\n\nlog_ratio = L_recent - L_ancient\nprintln(\"Log likelihood ratio: $log_ratio\")\n# Positive = recent divergence more likely\n\n","category":"section"},{"location":"guide/#Advanced-Models","page":"Theoretical Guide","title":"Advanced Models","text":"When to use which:\n\nSituation Use Example\nAntibodies, protein (no CDR boundaries) LG+G create_gamma_model(base_lg, 0.8)\nAntibodies, DNA (V region nucleotides) HKY85+G or JC69+G create_gamma_model(base_hky, 1.0)\nAntibodies (CDR/FR boundaries known) Partition model Different rates for CDR vs framework\nGeneral proteins with conserved/variable sites LG+G create_gamma_model(base_lg, 1.0)\nMulti-domain or multi-region sequences Partition model One model per region\n\nSee below for full examples and parameter guidance.","category":"section"},{"location":"guide/#Gamma-Rate-Variation-(G-Models)","page":"Theoretical Guide","title":"Gamma Rate Variation (+G Models)","text":"Real sequences have sites that evolve at different rates - some positions are highly conserved while others are hypervariable. The Gamma model accounts for this by drawing site rates from a discretized Gamma distribution. +G works with any base model, including DNA (JC69, HKY85, GTR) and protein (WAG, LG).\n\nProtein (e.g. antibody amino acid):\n\n# Create base model\nbase = create_model(LGModel, 1.0, normalize=true)\n\n# Add Gamma rate variation with 4 categories\n# Î± controls rate variation: smaller = more variation\nmodel = create_gamma_model(base, 0.5)   # High variation\nmodel = create_gamma_model(base, 1.0)   # Moderate variation  \nmodel = create_gamma_model(base, 2.0)   # Low variation\n\nDNA (e.g. antibody V region nucleotides): Use HKY85+G to capture both transition bias (SHM) and site-to-site rate variation:\n\nusing EvolutionModels\nusing BioSequences\n\nÏ€ = [0.25, 0.25, 0.25, 0.25]  # A, C, G, T\nÎº = 2.5   # Transition bias (typical for AID-mediated SHM)\nbase = create_model(HKY85Model, 1.0, Ï€, Îº, normalize=true)\nmodel = create_gamma_model(base, 1.0)  # Î±=1 for moderate rate variation\n\ngermline_nt = dna\"GAGGTGCAGCTGGTGGAGTCTGGGGGAGGCTTGGTACAGCCTGGGGGGTCCCTGAGACTCTCCTGTGCAGCCTCT\"\nmutated_nt  = dna\"GAGGTGCAGCTGGTGGAGTCTGGGGGAGGCTTGGTGCAGCCTGGGGGGTCCCTGAGACTCTCCTGTGCAGCCTCT\"\n\nlogL = sequence_likelihood(model, germline_nt, mutated_nt, 0.05)\nevolved = evolve_sequence(model, germline_nt, 0.05)\n\nWhen to use:\n\nSequences with mix of conserved and variable sites\nAntibody analysis at protein level (CDRs vs frameworks) or DNA level (V region)\nAny analysis where assuming uniform rates seems unrealistic\n\nParameter Î± guidance:\n\nÎ± value Rate variation Typical use\n0.3-0.5 Very high Highly heterogeneous data\n0.5-1.0 High Antibodies, proteins with functional constraints\n1.0-2.0 Moderate General protein analysis\n>2.0 Low Relatively homogeneous rates","category":"section"},{"location":"guide/#Partition-Models-(Region-Specific-Evolution)","page":"Theoretical Guide","title":"Partition Models (Region-Specific Evolution)","text":"For antibodies, CDR and framework regions evolve differently. Partition models apply different evolutionary parameters to different sequence regions.\n\n# Different models for different regions\nframework = create_model(LGModel, 1.0, normalize=true)\ncdr = create_model(LGModel, 2.0, normalize=true)  # 2Ã— rate for CDRs\n\n# IMGT numbering example for VH\nmodel = create_partition_model(\n    1:26 => framework,     # FR1\n    27:38 => cdr,          # CDR1\n    39:55 => framework,    # FR2\n    56:65 => cdr,          # CDR2\n    66:104 => framework,   # FR3\n    105:117 => cdr,        # CDR3\n    118:128 => framework   # FR4\n)\n\n# Use like any other model\nseq1 = aa\"...\"  # Your antibody sequence\nseq2 = aa\"...\"\nlogL = sequence_likelihood(model, seq1, seq2, 0.1)\n\nWhen to use:\n\nAntibody sequences with defined CDR/framework boundaries (e.g. IMGT numbering)\nMulti-domain proteins with different evolutionary pressures\nAny sequence with distinct functional regions\n\nAntibody example with partition model:\n\nusing EvolutionModels\nusing BioSequences\n\n# Framework and CDR models (CDRs evolve faster)\nframework = create_model(LGModel, 1.0, normalize=true)\ncdr = create_model(LGModel, 2.5, normalize=true)\n\nmodel = create_partition_model(\n    1:26 => framework, 27:38 => cdr,      # FR1, CDR1\n    39:55 => framework, 56:65 => cdr,     # FR2, CDR2\n    66:104 => framework, 105:117 => cdr,   # FR3, CDR3\n    118:128 => framework                   # FR4\n)\n\ngermline = aa\"EVQLVESGGGLVQPGGSLRLSCAASGFTFSSYAMSWVRQAPGKGLEWVSAISGSGGSTYYADSVKGRFTISRDNSKNTLYLQMNSLRAEDTAVYYCAK\"\nmutated  = aa\"EVQLVESGGGLVQPGRSLRLSCAASGFTFSSYWMSWVRQAPGKGLEWVANIKQDGSEKYYVDSVKGRFTISRDNAKNSLYLQMNSLRAEDTAVYYCAK\"\n\nlogL = sequence_likelihood(model, germline, mutated, 0.08)","category":"section"},{"location":"guide/#Combining-Approaches","page":"Theoretical Guide","title":"Combining Approaches","text":"You can use Gamma models as the base for partition models:\n\n# Framework: conserved, low rate variation\nframework_base = create_model(LGModel, 1.0, normalize=true)\nframework = create_gamma_model(framework_base, 2.0)  # Î±=2, low variation\n\n# CDR: hypervariable, high rate variation\ncdr_base = create_model(LGModel, 2.0, normalize=true)\ncdr = create_gamma_model(cdr_base, 0.5)  # Î±=0.5, high variation\n\nmodel = create_partition_model(\n    1:26 => framework,\n    27:38 => cdr,\n    # ... etc\n)\n\n","category":"section"},{"location":"guide/#Limitations-and-Considerations","page":"Theoretical Guide","title":"Limitations and Considerations","text":"","category":"section"},{"location":"guide/#Model-Assumptions","page":"Theoretical Guide","title":"Model Assumptions","text":"Basic models (JC69, HKY85, GTR, WAG, LG) assume:\n\nSite independence: Each position evolves independently\nTime reversibility: Process is stationary and reversible\nHomogeneous rates: Same process at all sites\n\nGamma models (+G) relax the homogeneous rates assumption by allowing site-specific rate variation.\n\nPartition models allow region-specific parameters but still assume independence within each region.","category":"section"},{"location":"guide/#Empirical-Models-and-SHM","page":"Theoretical Guide","title":"Empirical Models and SHM","text":"The WAG and LG matrices were derived from germline protein evolution across diverse protein families. Somatic hypermutation has distinct characteristics:\n\nAID-mediated with specific hotspot motifs\nStrong selection during affinity maturation\nRapid timescale (days to weeks vs millions of years)\n\nThe empirical models provide useful approximations but may not perfectly capture SHM patterns. For specialized applications, consider SHM-specific models from the literature.","category":"section"},{"location":"guide/#Gaps-and-Missing-Data","page":"Theoretical Guide","title":"Gaps and Missing Data","text":"Non-standard characters (gaps, ambiguous bases) are excluded from likelihood calculations. Heavily gapped alignments may produce unreliable results. Consider:\n\nQuality filtering before analysis\nAnalyzing gap patterns separately\nUsing alignment-free methods for highly divergent sequences\n\n","category":"section"},{"location":"guide/#References","page":"Theoretical Guide","title":"References","text":"Jukes, T.H. & Cantor, C.R. (1969). Evolution of Protein Molecules. Mammalian Protein Metabolism, 3:21-132.\nHasegawa, M., Kishino, H. & Yano, T. (1985). Dating of the human-ape splitting by a molecular clock of mitochondrial DNA. J Mol Evol, 22:160-174.\nTavarÃ©, S. (1986). Some probabilistic and statistical problems in the analysis of DNA sequences. Lectures on Mathematics in the Life Sciences, 17:57-86.\nWhelan, S. & Goldman, N. (2001). A general empirical model of protein evolution derived from multiple protein families using a maximum-likelihood approach. Mol Biol Evol, 18:691-699.\nLe, S.Q. & Gascuel, O. (2008). An improved general amino acid replacement matrix. Mol Biol Evol, 25:1307-1320.\nYang, Z. (2014). Molecular Evolution: A Statistical Approach. Oxford University Press.\nYaari, G. & Kleinstein, S.H. (2015). Practical guidelines for B-cell receptor repertoire sequencing analysis. Genome Med, 7:121.","category":"section"},{"location":"#EvolutionModels","page":"Home","title":"EvolutionModels","text":"Documentation for EvolutionModels.\n\nðŸš§ Work in Progress: This package is under active development.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"EvolutionModels.jl implements continuous-time Markov chain (CTMC) models for molecular sequence evolution. The package supports:\n\nDNA Models: JC69, HKY85, GTR\nProtein Models: WAG, LG (empirical amino acid substitution matrices)\nRate variation: Gamma (+G) and partition models for site- or region-specific rates (e.g. antibody CDR vs framework)\nSimulation: Evolve sequences along branches\nLikelihood: Compute probabilities of sequence pairs\nDistance Estimation: ML-based pairwise evolutionary distances","category":"section"},{"location":"#Mathematical-Foundation","page":"Home","title":"Mathematical Foundation","text":"","category":"section"},{"location":"#Continuous-Time-Markov-Chains","page":"Home","title":"Continuous-Time Markov Chains","text":"Sequence evolution is modeled as a continuous-time Markov process on the state space of nucleotides (A, C, G, T) or amino acids. The key mathematical objects are:\n\nQ (Rate Matrix): Instantaneous rates of change, with Qáµ¢â±¼ â‰¥ 0 for i â‰  j and row sums = 0\nP(t) = exp(Qt): Transition probability matrix for evolution over time t\nÏ€ (Stationary Distribution): Equilibrium frequencies satisfying Ï€Q = 0\n\nFor time-reversible models, detailed balance holds:\n\npi_i Q_ij = pi_j Q_ji\n\nThis is achieved by constructing Q from symmetric exchangeabilities S:\n\nQ_ij = S_ij cdot pi_j quad textfor  i neq j","category":"section"},{"location":"#Rate-Normalization","page":"Home","title":"Rate Normalization","text":"By default, the overall evolutionary rate depends on Î¼. Use normalize=true to scale Q so that:\n\n-sum_i pi_i Q_ii = 1\n\nThis means branch length t directly represents the expected number of substitutions per site.","category":"section"},{"location":"#DNA-Substitution-Models","page":"Home","title":"DNA Substitution Models","text":"","category":"section"},{"location":"#Jukes-Cantor-(JC69)","page":"Home","title":"Jukes-Cantor (JC69)","text":"The simplest model assuming:\n\nEqual base frequencies: Ï€A = Ï€C = Ï€G = Ï€T = 1/4\nEqual substitution rates between all nucleotides\n\nRate matrix:\n\nQ = beginpmatrix\n-3alpha  alpha  alpha  alpha \nalpha  -3alpha  alpha  alpha \nalpha  alpha  -3alpha  alpha \nalpha  alpha  alpha  -3alpha\nendpmatrix\n\nwhere Î± = Î¼/4 (or Î± = 1/3 when normalized)","category":"section"},{"location":"#HKY85-Model","page":"Home","title":"HKY85 Model","text":"Extends JC69 with:\n\nArbitrary base frequencies (Ï€A, Ï€C, Ï€G, Ï€T)\nDifferent rates for transitions (Aâ†”G, Câ†”T) vs transversions\nRate ratio Îº between transitions and transversions\n\nq_ij = begincases\nmukappapi_j  textfor transitions \nmupi_j  textfor transversions \n-sum_kneq i q_ik  textfor  i = j\nendcases","category":"section"},{"location":"#General-Time-Reversible-(GTR)","page":"Home","title":"General Time-Reversible (GTR)","text":"Most general neutral, reversible model:\n\nArbitrary base frequencies Ï€\nSix exchangeability parameters (rAC, rAG, rAT, rCG, rCT, rGT)\nSatisfies detailed balance","category":"section"},{"location":"#Protein-Substitution-Models","page":"Home","title":"Protein Substitution Models","text":"","category":"section"},{"location":"#WAG-Model","page":"Home","title":"WAG Model","text":"Empirical amino acid substitution matrix derived from 182 protein families (Whelan & Goldman, 2001). Provides both exchangeabilities and equilibrium frequencies estimated via maximum likelihood.","category":"section"},{"location":"#LG-Model","page":"Home","title":"LG Model","text":"Improved empirical matrix from 3,912 protein families (Le & Gascuel, 2008). Generally recommended for modern protein sequence analysis.","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"#Creating-Models","page":"Home","title":"Creating Models","text":"using EvolutionModels\nusing BioSequences\n\n# JC69 - simplest DNA model\nmodel_jc = create_model(JC69Model, 1.0)\n\n# JC69 normalized (1 expected substitution per unit time)\nmodel_jc_norm = create_model(JC69Model, 1.0, normalize=true)\n\n# HKY85 with custom frequencies and transition bias\nÏ€ = [0.3, 0.2, 0.2, 0.3]  # A,C,G,T\nÎº = 2.0  # transitions 2Ã— faster than transversions\nmodel_hky = create_model(HKY85Model, 1.0, Ï€, Îº, normalize=true)\n\n# GTR with full parameterization\nrates = [0.0 1.0 2.0 1.0;\n         1.0 0.0 1.0 2.0;\n         2.0 1.0 0.0 1.0;\n         1.0 2.0 1.0 0.0]\nmodel_gtr = create_model(GTRModel, 1.0, Ï€, rates, normalize=true)\n\n# Protein models\nmodel_wag = create_model(WAGModel, 1.0, normalize=true)\nmodel_lg = create_model(LGModel, 1.0, normalize=true)","category":"section"},{"location":"#Sequence-Evolution-Simulation","page":"Home","title":"Sequence Evolution Simulation","text":"# DNA evolution\nmodel = create_model(JC69Model, 1.0, normalize=true)\nseq = dna\"ATCGATCGATCGATCG\"\nevolved = evolve_sequence(model, seq, 0.1)  # t=0.1 expected subs/site\n\n# Protein evolution\nmodel_aa = create_model(LGModel, 1.0, normalize=true)\nprotein = aa\"EVQLVESGGGLVQPGGSLRL\"\nevolved_aa = evolve_sequence(model_aa, protein, 0.1)","category":"section"},{"location":"#Likelihood-Computation","page":"Home","title":"Likelihood Computation","text":"model = create_model(JC69Model, 1.0, normalize=true)\nseq1 = dna\"ATCGATCG\"\nseq2 = dna\"ATTGATCG\"\n\n# Compute log P(seq2 | seq1, t)\nlogL = sequence_likelihood(model, seq1, seq2, 0.1)","category":"section"},{"location":"#Distance-Matrix-Computation","page":"Home","title":"Distance Matrix Computation","text":"Requires FASTX.jl and Optim.jl:\n\nusing EvolutionModels\nusing FASTX\nusing Optim\n\n# Read alignment\naln = read_alignment(\"sequences.fasta\")\n\n# Compute pairwise distances\nmodel = create_model(JC69Model, 1.0, normalize=true)\nresult = compute_distances(model, aln)\n\n# Access results\nD = result.distances  # Distance matrix\nlabels = result.labels  # Sequence names","category":"section"},{"location":"#Antibody-Sequence-Analysis","page":"Home","title":"Antibody Sequence Analysis","text":"EvolutionModels.jl is well-suited for analyzing antibody evolution, including somatic hypermutation and B cell lineage analysis.\n\nRecommended for antibodies: Use Gamma (+G) or partition models, since CDR and framework regions evolve at different rates. See the Theoretical Guide for when to use each and full examples.\n\nLG+G: Single model with site-to-site rate variation (good default when you don't have CDR boundaries).\nPartition model: Different models per region when you know CDR/FR boundaries (e.g. IMGT numbering).","category":"section"},{"location":"#Analyzing-VH-Region-Evolution","page":"Home","title":"Analyzing VH Region Evolution","text":"using EvolutionModels\nusing BioSequences\n\n# Recommended: LG+G for rate variation (CDRs vs frameworks)\nbase = create_model(LGModel, 1.0, normalize=true)\nmodel = create_gamma_model(base, 0.8)  # Î±=0.8 typical for antibodies\n\n# Or plain LG if you prefer a simple model\n# model = create_model(LGModel, 1.0, normalize=true)\n\n# Germline VH sequence (IGHV3-23*01)\ngermline = aa\"EVQLVESGGGLVQPGGSLRLSCAASGFTFSSYAMSWVRQAPGKGLEWVSAISGSGGSTYYADSVKGRFTISRDNSKNTLYLQMNSLRAEDTAVYYCAK\"\n\n# Somatically mutated antibody\nmutated = aa\"EVQLVESGGGLVQPGRSLRLSCAASGFTFSSYWMSWVRQAPGKGLEWVANIKQDGSEKYYVDSVKGRFTISRDNAKNSLYLQMNSLRAEDTAVYYCAK\"\n\n# Compute likelihood at different evolutionary distances\nfor t in [0.01, 0.05, 0.10, 0.20]\n    ll = sequence_likelihood(model, germline, mutated, t)\n    println(\"t=$t: log-likelihood = $(round(ll, digits=2))\")\nend","category":"section"},{"location":"#Simulating-Somatic-Hypermutation","page":"Home","title":"Simulating Somatic Hypermutation","text":"using EvolutionModels\nusing BioSequences\nusing Random\n\nRandom.seed!(42)\n\nmodel = create_model(LGModel, 1.0, normalize=true)\n\n# Germline antibody\ngermline = aa\"EVQLVESGGGLVQPGGSLRLSCAASGFTFSSYAMSWVRQAPGKGLEWVSAISGSGGSTYYADSVKGRFTISRDNSKNTLYLQMNSLRAEDTAVYYCAK\"\n\n# Simulate evolution at increasing distances\nprintln(\"Simulating somatic hypermutation:\")\nfor t in [0.02, 0.05, 0.10, 0.15]\n    evolved = evolve_sequence(model, germline, t)\n    n_mut = count(g != e for (g, e) in zip(germline, evolved))\n    pct = round(100 * n_mut / length(germline), digits=1)\n    println(\"  t=$t: $n_mut mutations ($pct%)\")\nend","category":"section"},{"location":"#DNA-Level-Analysis-with-Transition-Bias","page":"Home","title":"DNA-Level Analysis with Transition Bias","text":"Somatic hypermutation shows bias toward transitions. Model this with HKY85:\n\nusing EvolutionModels\nusing BioSequences\n\n# HKY85 with transition bias (Îº > 1)\nÏ€ = [0.25, 0.25, 0.25, 0.25]\nÎº = 2.5  # Transitions favored\nmodel = create_model(HKY85Model, 1.0, Ï€, Îº, normalize=true)\n\n# VH nucleotide sequence\ngermline_nt = dna\"GAGGTGCAGCTGGTGGAGTCTGGGGGAGGCTTGGTACAGCCTGGGGGGTCCCTGAGACTCTCCTGTGCAGCCTCT\"\n\n# Simulate mutations\nmutated_nt = evolve_sequence(model, germline_nt, 0.05)\n\n# Analyze mutation spectrum\ntransitions = 0\ntransversions = 0\nfor (g, m) in zip(germline_nt, mutated_nt)\n    if g != m\n        if (g == DNA_A && m == DNA_G) || (g == DNA_G && m == DNA_A) ||\n           (g == DNA_C && m == DNA_T) || (g == DNA_T && m == DNA_C)\n            transitions += 1\n        else\n            transversions += 1\n        end\n    end\nend\nprintln(\"Transitions: $transitions, Transversions: $transversions\")\nprintln(\"Ti/Tv ratio: $(round(transitions/max(transversions,1), digits=2))\")","category":"section"},{"location":"#B-Cell-Lineage-Distance-Matrix","page":"Home","title":"B Cell Lineage Distance Matrix","text":"using EvolutionModels\nusing FASTX\nusing Optim\n\n# Read aligned antibody sequences from a B cell lineage\n# (germline + clonally-related sequences)\naln = read_alignment(\"bcell_lineage.fasta\")\n\n# Compute evolutionary distances\nmodel = create_model(WAGModel, 1.0, normalize=true)\nresult = compute_distances(model, aln)\n\n# Print formatted distance matrix\nprint_distance_matrix(result)\n\n# Distances can be used for:\n# - Phylogenetic tree reconstruction (e.g., with Phylogenetics.jl)\n# - Hierarchical clustering\n# - Identifying clonal relationships","category":"section"},{"location":"#Interpreting-Distances-for-Antibodies","page":"Home","title":"Interpreting Distances for Antibodies","text":"When using normalized models, the evolutionary distance t represents expected amino acid substitutions per site:\n\nDistance (t) Interpretation\n0.01-0.03 Low SHM, early in affinity maturation\n0.05-0.10 Moderate SHM, typical memory B cell\n0.10-0.20 High SHM, extensively mutated\n> 0.20 Very high mutation load","category":"section"},{"location":"#Model-Comparison","page":"Home","title":"Model Comparison","text":"Model States Parameters Use Case\nJC69 DNA (4) 1 (Î¼) Quick estimates, equal rates\nHKY85 DNA (4) 4+Îº Transition/transversion bias\nGTR DNA (4) 4+6 Full flexibility\nWAG Protein (20) 1 (Î¼) General protein evolution\nLG Protein (20) 1 (Î¼) Modern protein analysis\nLG+G Protein (20) 1+Î± Rate variation (e.g. antibodies) â€” see Theoretical Guide\nPartition Any per region Different regions (e.g. CDR vs framework) â€” see Theoretical Guide","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#EvolutionModels.DNAModel","page":"Home","title":"EvolutionModels.DNAModel","text":"DNAModel <: EvolutionModel\n\nAbstract type for DNA evolution models.\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.EvolutionModel","page":"Home","title":"EvolutionModels.EvolutionModel","text":"EvolutionModel\n\nAbstract type for all molecular evolution models.\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.GammaRateModel","page":"Home","title":"EvolutionModels.GammaRateModel","text":"GammaRateModel{S<:SequenceType}\n\nEvolution model with discrete Gamma rate variation across sites.\n\nWraps a base Model and adds rate categories from a discretized Gamma distribution. This accounts for site-to-site rate heterogeneity common in biological sequences.\n\nFields\n\nbase_model::Model{S}: The underlying substitution model\nÎ±::Float64: Gamma shape parameter (smaller = more variation)\nrates::Vector{Float64}: Discrete rate categories\nweights::Vector{Float64}: Probability of each rate category (typically uniform)\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.Model","page":"Home","title":"EvolutionModels.Model","text":"Model{S<:SequenceType}\n\nConcrete implementation of an evolution model.\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.PartitionModel","page":"Home","title":"EvolutionModels.PartitionModel","text":"PartitionModel\n\nModel that applies different evolutionary models to different sequence regions.\n\nUseful for analyzing sequences with distinct evolutionary patterns, such as antibody CDR vs framework regions.\n\nFields\n\npartitions::Vector{Tuple{UnitRange{Int}, Model}}: List of (site_range, model) pairs\ntotal_length::Int: Total sequence length covered\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.ProteinModel","page":"Home","title":"EvolutionModels.ProteinModel","text":"ProteinModel <: EvolutionModel\n\nAbstract type for protein evolution models.\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.SequenceType","page":"Home","title":"EvolutionModels.SequenceType","text":"SequenceType\n\nAbstract type for sequence alphabets (DNA or Protein).\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.compute_q_matrix-Tuple{Matrix{Float64}, LinearAlgebra.Diagonal{Float64, V} where V<:AbstractVector{Float64}}","page":"Home","title":"EvolutionModels.compute_q_matrix","text":"Compute Q matrix (generator matrix) from R and P.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_gamma_model-Union{Tuple{S}, Tuple{Model{S}, Float64}} where S","page":"Home","title":"EvolutionModels.create_gamma_model","text":"create_gamma_model(base_model::Model, Î±::Float64; n_categories::Int=4)\n\nCreate a model with discrete Gamma rate variation across sites.\n\nArguments\n\nbase_model::Model: The underlying substitution model (e.g., LG, WAG, HKY85)\nÎ±::Float64: Gamma shape parameter. Smaller values = more rate variation:\nÎ± < 1: High variation (some sites very slow, some very fast)\nÎ± â‰ˆ 1: Moderate variation\nÎ± > 2: Low variation\nÎ± â†’ âˆž: No variation (equivalent to base model)\nn_categories::Int=4: Number of discrete rate categories (typically 4-8)\n\nReturns\n\nGammaRateModel: Model with rate heterogeneity\n\nExample\n\n# Create LG+G4 model (LG with 4 Gamma rate categories)\nbase = create_model(LGModel, 1.0, normalize=true)\nmodel = create_gamma_model(base, 0.5)  # Î±=0.5 for high rate variation\n\n# For antibodies, moderate variation is common\nmodel = create_gamma_model(base, 1.0)  # Î±=1.0\n\nReferences\n\nYang, Z. (1994). Maximum likelihood phylogenetic estimation from DNA sequences with variable rates over sites. J Mol Evol, 39:306-314.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_model-Tuple{Type{GTRModel}, Float64, Vector{Float64}, Matrix{Float64}}","page":"Home","title":"EvolutionModels.create_model","text":"create_model(::Type{GTRModel}, Î¼::Float64, Ï€::Vector{Float64}, rates::Matrix{Float64}; normalize::Bool=false) -> Model{DNAType}\n\nCreate a General Time-Reversible (GTR) model of DNA evolution.\n\nThe GTR model is the most general neutral, independent sites, reversible model:\n\nArbitrary base frequencies Ï€\nArbitrary symmetric rate matrix\nSatisfies detailed balance: Ï€áµ¢qáµ¢â±¼ = Ï€â±¼qâ±¼áµ¢\n\nArguments\n\nÎ¼::Float64: Overall mutation rate scaling factor (must be positive)\nÏ€::Vector{Float64}: Vector of base frequencies [Ï€A, Ï€C, Ï€G, Ï€T], must sum to 1\nrates::Matrix{Float64}: 4Ã—4 symmetric matrix of relative substitution rates\nnormalize::Bool=false: If true, normalize Q so expected substitutions per unit time = 1\n\nReturns\n\nModel{DNAType}: A GTR model with rate matrix Q = Î¼Râ‹…diag(Ï€) where:\nR is the symmetric rate matrix\nqáµ¢â±¼ = Î¼ráµ¢â±¼Ï€â±¼ for i â‰  j\nqáµ¢áµ¢ = -âˆ‘â±¼â‰ áµ¢ qáµ¢â±¼\n\nExample\n\n# Create GTR model with custom rates\nÏ€ = [0.3, 0.2, 0.2, 0.3]  # Base frequencies\nrates = [0.0 1.0 2.0 1.0;  # Symmetric rate matrix\n         1.0 0.0 1.0 2.0;\n         2.0 1.0 0.0 1.0;\n         1.0 2.0 1.0 0.0]\nmodel = create_model(GTRModel, 0.1, Ï€, rates)\n\n# Create normalized model\nmodel_norm = create_model(GTRModel, 1.0, Ï€, rates, normalize=true)\n\nReferences\n\nTavarÃ©, S. (1986). Some probabilistic and statistical problems in the analysis of DNA sequences. Lectures on Mathematics in the Life Sciences, 17:57-86.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_model-Tuple{Type{HKY85Model}, Float64, Vector{Float64}, Float64}","page":"Home","title":"EvolutionModels.create_model","text":"create_model(::Type{HKY85Model}, Î¼::Float64, Ï€::Vector{Float64}, Îº::Float64; normalize::Bool=false) -> Model{DNAType}\n\nCreate a Hasegawa-Kishino-Yano (1985) model of DNA evolution.\n\nThe HKY85 model features:\n\nArbitrary base frequencies Ï€\nDifferent rates for transitions (Aâ†”G, Câ†”T) vs transversions\nRate ratio Îº between transitions and transversions\n\nArguments\n\nÎ¼::Float64: Overall mutation rate scaling factor (must be positive)\nÏ€::Vector{Float64}: Vector of base frequencies [Ï€A, Ï€C, Ï€G, Ï€T], must sum to 1\nÎº::Float64: Transition/transversion rate ratio (must be positive)\nnormalize::Bool=false: If true, normalize Q so expected substitutions per unit time = 1\n\nReturns\n\nModel{DNAType}: An HKY85 model with rate matrix Q where:\nqáµ¢â±¼ = Î¼ÎºÏ€â±¼ for transitions\nqáµ¢â±¼ = Î¼Ï€â±¼ for transversions\nqáµ¢áµ¢ = -âˆ‘â±¼â‰ áµ¢ qáµ¢â±¼\n\nExample\n\n# Create HKY85 model with unequal base frequencies\nÏ€ = [0.3, 0.2, 0.2, 0.3]  # A,C,G,T frequencies\nmodel = create_model(HKY85Model, 0.1, Ï€, 2.0)  # Îº=2 means transitions occur 2Ã— faster\n\n# Create normalized model\nmodel_norm = create_model(HKY85Model, 1.0, Ï€, 2.0, normalize=true)\n\nReferences\n\nHasegawa, M., Kishino, H., and Yano, T. (1985). Dating of the human-ape splitting by a molecular clock of mitochondrial DNA. J. Mol. Evol., 22(2):160-174.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_model-Tuple{Type{JC69Model}, Float64}","page":"Home","title":"EvolutionModels.create_model","text":"create_model(::Type{JC69Model}, Î¼::Float64; normalize::Bool=false) -> Model{DNAType}\n\nCreate a Jukes-Cantor (1969) model of DNA evolution.\n\nThe JC69 model assumes:\n\nEqual base frequencies (Ï€ = 0.25 for all bases)\nEqual substitution rates between all nucleotides\nSingle parameter Î¼ controlling overall mutation rate\n\nArguments\n\nÎ¼::Float64: Overall mutation rate scaling factor (must be positive)\nnormalize::Bool=false: If true, normalize Q so expected substitutions per unit time = 1\n\nReturns\n\nModel{DNAType}: A JC69 model with rate matrix Q where:\nqáµ¢â±¼ = Î¼/4 for i â‰  j (off-diagonal elements)  \nqáµ¢áµ¢ = -3Î¼/4 (diagonal elements)\nIf normalized: qáµ¢â±¼ = 1/3 for i â‰  j, qáµ¢áµ¢ = -1\n\nExample\n\n# Create JC69 model with rate 0.1\nmodel = create_model(JC69Model, 0.1)\n\n# Create normalized model (1 expected substitution per unit time)\nmodel_norm = create_model(JC69Model, 1.0, normalize=true)\n\n# Access model properties\nÏ€ = stationary_frequencies(model)  # All 0.25\nR = rate_matrix(model)  # Symmetric rate matrix\n\nReferences\n\nJukes, T.H. and Cantor, C.R. (1969). Evolution of Protein Molecules.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_model-Tuple{Type{LGModel}, Float64}","page":"Home","title":"EvolutionModels.create_model","text":"create_model(::Type{LGModel}, Î¼::Float64; normalize::Bool=false)\n\nCreate an LG (Le-Gascuel) protein evolution model with specified rate scaling factor Î¼. Returns a Model{ProteinType} with empirical substitution rates and frequencies.\n\nThe LG model is derived from 3,912 protein families using maximum likelihood methods, improving upon previous models by incorporating rate variation across sites. The amino acid order follows STANDARD_AA: A R N D C Q E G H I L K M F P S T W Y V\n\nCitation\n\nLe, S. Q., & Gascuel, O. (2008). An improved general amino acid replacement matrix. Molecular Biology and Evolution, 25(7), 1307-1320. DOI: 10.1093/molbev/msn067\n\nArguments\n\nÎ¼::Float64: Rate scaling factor (must be positive)\nnormalize::Bool=false: If true, normalize Q so expected substitutions per unit time = 1\n\nReturns\n\nModel{ProteinType}: Configured LG model\n\nExample\n\n# Create normalized LG model for antibody analysis\nmodel = create_model(LGModel, 1.0, normalize=true)\n\n# Compute evolutionary distance between antibody sequences\nseq1 = aa\"EVQLVESGGGLVQPGGSLRLSCAAS\"\nseq2 = aa\"EVQLVESGGGLVQPGRSLRLSCAAS\"\nlogL = sequence_likelihood(model, seq1, seq2, 0.05)\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_model-Tuple{Type{WAGModel}, Float64}","page":"Home","title":"EvolutionModels.create_model","text":"create_model(::Type{WAGModel}, Î¼::Float64; normalize::Bool=false)\n\nCreate a WAG (Whelan And Goldman) protein evolution model with specified rate scaling factor Î¼. Returns a Model{ProteinType} with empirical substitution rates and frequencies.\n\nThe WAG model is derived from 182 protein families using maximum likelihood methods, providing both substitution rates and equilibrium frequencies estimated from the data. The amino acid order follows STANDARD_AA: A R N D C Q E G H I L K M F P S T W Y V\n\nCitation\n\nWhelan, S., & Goldman, N. (2001). A general empirical model of protein evolution derived from multiple protein families using a maximum-likelihood approach. Molecular Biology and Evolution, 18(5), 691-699. DOI: 10.1093/oxfordjournals.molbev.a003851\n\nArguments\n\nÎ¼::Float64: Rate scaling factor (must be positive)\nnormalize::Bool=false: If true, normalize Q so expected substitutions per unit time = 1\n\nReturns\n\nModel{ProteinType}: Configured WAG model\n\nExample\n\n# Create WAG model for antibody sequence analysis\nmodel = create_model(WAGModel, 1.0, normalize=true)\n\n# Evolve an antibody variable region sequence\nseq = aa\"EVQLVESGGGLVQPGGSLRLSCAAS\"\nevolved = evolve_sequence(model, seq, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_partition_model-Tuple{Vararg{Pair{UnitRange{Int64}, <:Model}}}","page":"Home","title":"EvolutionModels.create_partition_model","text":"create_partition_model(partitions::Pair{UnitRange{Int}, Model}...)\n\nCreate a partition model with different models for different sequence regions.\n\nArguments\n\npartitions...: Variable number of range => model pairs\n\nReturns\n\nPartitionModel: Model with region-specific parameters\n\nExample\n\n# Antibody with different models for CDR and framework\nframework_model = create_model(LGModel, 1.0, normalize=true)\ncdr_model = create_model(LGModel, 2.0, normalize=true)  # Higher rate for CDRs\n\n# Define regions (IMGT numbering example)\nmodel = create_partition_model(\n    1:26 => framework_model,     # FR1\n    27:38 => cdr_model,          # CDR1\n    39:55 => framework_model,    # FR2\n    56:65 => cdr_model,          # CDR2\n    66:104 => framework_model,   # FR3\n    105:117 => cdr_model,        # CDR3\n    118:128 => framework_model   # FR4\n)\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.discrete_gamma_rates","page":"Home","title":"EvolutionModels.discrete_gamma_rates","text":"discrete_gamma_rates(Î±::Float64, n_categories::Int=4) -> Tuple{Vector{Float64}, Vector{Float64}}\n\nCompute discrete Gamma rate categories using the mean of each category.\n\nThe Gamma distribution has shape Î± and rate Î± (so mean = 1). The distribution is divided into n_categories equiprobable categories, and the mean rate for each category is returned.\n\nArguments\n\nÎ±::Float64: Shape parameter (smaller = more rate variation, Î±â†’âˆž = no variation)\nn_categories::Int=4: Number of discrete rate categories\n\nReturns\n\nTuple{Vector{Float64}, Vector{Float64}}: (rates, weights) where weights are all 1/n_categories\n\nExample\n\nrates, weights = discrete_gamma_rates(0.5, 4)\n# rates â‰ˆ [0.03, 0.28, 0.92, 2.77] - wide variation\n# weights = [0.25, 0.25, 0.25, 0.25]\n\nrates, weights = discrete_gamma_rates(10.0, 4)  \n# rates â‰ˆ [0.70, 0.90, 1.05, 1.35] - little variation\n\nReferences\n\nYang, Z. (1994). Maximum likelihood phylogenetic estimation from DNA sequences  with variable rates over sites. J Mol Evol, 39:306-314.\n\n\n\n\n\n","category":"function"},{"location":"#EvolutionModels.evolve_sequence-Tuple{GammaRateModel{DNAType}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, Float64}","page":"Home","title":"EvolutionModels.evolve_sequence","text":"evolve_sequence(model::GammaRateModel{DNAType}, seq::LongDNA{4}, t::Float64; rng=Random.GLOBAL_RNG)\n\nSimulate evolution with site-specific rates drawn from Gamma distribution.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.evolve_sequence-Tuple{GammaRateModel{ProteinType}, BioSequences.LongAA, Float64}","page":"Home","title":"EvolutionModels.evolve_sequence","text":"evolve_sequence(model::GammaRateModel{ProteinType}, seq::LongAA, t::Float64; rng=Random.GLOBAL_RNG)\n\nSimulate protein evolution with site-specific rates.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.evolve_sequence-Tuple{Model{DNAType}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, Float64}","page":"Home","title":"EvolutionModels.evolve_sequence","text":"evolve_sequence(model::Model{DNAType}, seq::LongDNA{4}, t::Float64; \n               rng::AbstractRNG=Random.GLOBAL_RNG) -> LongDNA{4}\n\nSimulate DNA sequence evolution under a continuous-time Markov model for time t.\n\nThe function implements the following process:\n\nComputes transition probability matrix P(t) = exp(Qt)\nFor each site, samples new nucleotide from the probability distribution given by the corresponding row of P(t)\nPreserves non-standard nucleotides (gaps, ambiguous bases) unchanged\n\nArguments\n\nmodel::Model{DNAType}: DNA evolution model (JC69, HKY85, or GTR)\nseq::LongDNA{4}: Input DNA sequence\nt::Float64: Evolution time (branch length)\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator\n\nReturns\n\nLongDNA{4}: Evolved DNA sequence of the same length as input\n\nExample\n\n# Create model and evolve sequence\nmodel = create_model(JC69Model, 0.1)\nseq = dna\"ATCG\"\nevolved = evolve_sequence(model, seq, 1.0)\n\n# Use specific RNG for reproducibility\nrng = MersenneTwister(42)\nevolved = evolve_sequence(model, seq, 1.0, rng=rng)\n\nNote: For very small t, few changes are expected. As tâ†’âˆž, nucleotide frequencies approach the model's stationary distribution Ï€.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.evolve_sequence-Tuple{Model{ProteinType}, BioSequences.LongAA, Float64}","page":"Home","title":"EvolutionModels.evolve_sequence","text":"evolve_sequence(model::Model{ProteinType}, seq::LongAA, t::Float64; \n               rng::AbstractRNG=Random.GLOBAL_RNG) -> LongAA\n\nSimulate protein sequence evolution under empirical amino acid substitution models.\n\nThe function implements the following process:\n\nComputes transition probability matrix P(t) = exp(Qt)\nFor each site, samples new amino acid from the probability distribution given by the corresponding row of P(t)\nPreserves non-standard amino acids (gaps, ambiguous residues) unchanged\n\nArguments\n\nmodel::Model{ProteinType}: Protein evolution model (WAG or LG)\nseq::LongAA: Input amino acid sequence\nt::Float64: Evolution time (branch length)\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator\n\nReturns\n\nLongAA: Evolved amino acid sequence of the same length as input\n\nExample\n\n# Create model and evolve sequence\nmodel = create_model(WAGModel, 0.1)\nseq = aa\"ARND\"\nevolved = evolve_sequence(model, seq, 1.0)\n\nNote: The empirical models (WAG, LG) use pre-computed rate matrices derived from large protein alignments, representing \"average\" evolutionary patterns.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.evolve_sequence-Tuple{PartitionModel, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, Float64}","page":"Home","title":"EvolutionModels.evolve_sequence","text":"evolve_sequence(model::PartitionModel, seq::Union{LongDNA{4},LongAA}, t::Float64; rng=Random.GLOBAL_RNG)\n\nSimulate evolution with region-specific models.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.expected_substitution_rate-Tuple{Matrix{Float64}, Vector{Float64}}","page":"Home","title":"EvolutionModels.expected_substitution_rate","text":"expected_substitution_rate(Q::Matrix{Float64}, Ï€::Vector{Float64}) -> Float64\n\nCompute the expected number of substitutions per unit time for a rate matrix Q with stationary distribution Ï€.\n\nFormula\n\nbeta = -sum_i pi_i Q_ii\n\nArguments\n\nQ::Matrix{Float64}: Rate matrix\nÏ€::Vector{Float64}: Stationary frequencies\n\nReturns\n\nFloat64: Expected substitutions per unit time\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.gamma_cdf-Tuple{Float64, Float64}","page":"Home","title":"EvolutionModels.gamma_cdf","text":"Gamma CDF using series expansion.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.gamma_pdf-Tuple{Float64, Float64}","page":"Home","title":"EvolutionModels.gamma_pdf","text":"Gamma PDF for Gamma(Î±, Î±) distribution.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.gamma_quantile-Tuple{Float64, Float64}","page":"Home","title":"EvolutionModels.gamma_quantile","text":"gamma_quantile(Î±::Float64, p::Float64) -> Float64\n\nCompute the p-th quantile of Gamma(Î±, Î±) distribution using Newton-Raphson iteration.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.is_transition-Tuple{BioSymbols.DNA, BioSymbols.DNA}","page":"Home","title":"EvolutionModels.is_transition","text":"Check if two symbols are transitions (Aâ†”G or Câ†”T)\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.load_empirical_data-Tuple{String}","page":"Home","title":"EvolutionModels.load_empirical_data","text":"load_empirical_data(filepath::String)\n\nLoad empirical substitution matrix and frequencies from a data file. Internal helper function for specific model loaders.\n\nFormat\n\nFile should contain:\n\nLines 1-19: Lower triangular elements of the 20Ã—20 substitution rate matrix\nLine 22: Vector of 20 equilibrium frequencies\n\nThe amino acid order follows STANDARD_AA: A R N D C Q E G H I L K M F P S T W Y V\n\nArguments\n\nfilepath::String: Path to the data file\n\nReturns\n\nTuple{Matrix{Float64}, Vector{Float64}}: Rate matrix and frequency vector\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.load_lg_frequencies-Tuple{}","page":"Home","title":"EvolutionModels.load_lg_frequencies","text":"load_lg_frequencies()\n\nLoad LG amino acid frequencies from LG.dat. Returns equilibrium frequencies in STANDARD_AA order.\n\nCitation\n\nLe & Gascuel (2008). DOI: 10.1093/molbev/msn067\n\nReturns\n\nVector{Float64}: Vector of 20 equilibrium frequencies\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.load_lg_rates-Tuple{}","page":"Home","title":"EvolutionModels.load_lg_rates","text":"load_lg_rates()\n\nLoad LG substitution rates matrix from LG.dat. Returns a 20Ã—20 symmetric matrix of amino acid substitution rates.\n\nCitation\n\nLe & Gascuel (2008). DOI: 10.1093/molbev/msn067\n\nReturns\n\nMatrix{Float64}: 20Ã—20 symmetric rate matrix\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.load_wag_frequencies-Tuple{}","page":"Home","title":"EvolutionModels.load_wag_frequencies","text":"load_wag_frequencies()\n\nLoad WAG amino acid frequencies from WAG.dat. Returns equilibrium frequencies in STANDARD_AA order.\n\nCitation\n\nWhelan & Goldman (2001). DOI: 10.1093/oxfordjournals.molbev.a003851\n\nReturns\n\nVector{Float64}: Vector of 20 equilibrium frequencies\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.load_wag_rates-Tuple{}","page":"Home","title":"EvolutionModels.load_wag_rates","text":"load_wag_rates()\n\nLoad WAG substitution rates matrix from WAG.dat. Returns a 20Ã—20 symmetric matrix of amino acid substitution rates.\n\nCitation\n\nWhelan & Goldman (2001). DOI: 10.1093/oxfordjournals.molbev.a003851\n\nReturns\n\nMatrix{Float64}: 20Ã—20 symmetric rate matrix\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.lower_incomplete_gamma-Tuple{Float64, Float64}","page":"Home","title":"EvolutionModels.lower_incomplete_gamma","text":"Lower incomplete gamma function using series expansion.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.normalize_rate_matrix!-Tuple{Matrix{Float64}, Vector{Float64}}","page":"Home","title":"EvolutionModels.normalize_rate_matrix!","text":"normalize_rate_matrix!(Q::Matrix{Float64}, Ï€::Vector{Float64})\n\nNormalize the rate matrix Q in-place so that the expected number of  substitutions per unit time equals 1.\n\nThe normalization factor is Î² = -âˆ‘áµ¢ Ï€áµ¢ Qáµ¢áµ¢, and Q is divided by Î².\n\nArguments\n\nQ::Matrix{Float64}: Rate matrix to normalize (modified in-place)\nÏ€::Vector{Float64}: Stationary frequencies\n\nReturns\n\nFloat64: The normalization factor Î² used\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.quantile_normal-Tuple{Float64}","page":"Home","title":"EvolutionModels.quantile_normal","text":"Standard normal quantile using rational approximation.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.rate_matrix-Tuple{Model}","page":"Home","title":"EvolutionModels.rate_matrix","text":"Get the rate matrix R (includes Î¼ scaling).\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.sequence_likelihood-Tuple{GammaRateModel, Union{BioSequences.LongAA, BioSequences.LongDNA{4}, BioSequences.LongNuc{4, BioSequences.DNAAlphabet{4}}}, Union{BioSequences.LongAA, BioSequences.LongDNA{4}, BioSequences.LongNuc{4, BioSequences.DNAAlphabet{4}}}, Float64}","page":"Home","title":"EvolutionModels.sequence_likelihood","text":"sequence_likelihood(model::GammaRateModel, seq1, seq2, t::Float64; joint::Bool=false)\n\nCompute likelihood integrating over Gamma rate categories.\n\nFor each site, the likelihood is averaged over all rate categories:\n\nP(y_k  x_k t) = sum_r w_r P(t cdot r)_x_k y_k\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.sequence_likelihood-Tuple{Model, Union{BioSequences.LongAA, BioSequences.LongDNA{4}, BioSequences.LongNuc{4, BioSequences.DNAAlphabet{4}}}, Union{BioSequences.LongAA, BioSequences.LongDNA{4}, BioSequences.LongNuc{4, BioSequences.DNAAlphabet{4}}}, Float64}","page":"Home","title":"EvolutionModels.sequence_likelihood","text":"sequence_likelihood(model::Model, seq1::Union{LongDNA{4},LongAA}, \n                   seq2::Union{LongDNA{4},LongAA}, t::Float64;\n                   joint::Bool=false) -> Float64\n\nCompute the log-probability of observing two sequences separated by evolutionary  time t under the given model.\n\nConditional likelihood (default, joint=false):\n\nlog P(textseq2  textseq1 t) = sum_i log P(t)_x_1i x_2i\n\nJoint likelihood (joint=true):\n\nlog P(textseq1 textseq2  t) = sum_i left log pi_x_1i + log P(t)_x_1i x_2i right\n\nwhere P(t) = exp(Qt) is the transition probability matrix, Ï€ is the stationary  distribution, and xâ‚áµ¢, xâ‚‚áµ¢ are states at position i.\n\nArguments\n\nmodel::Model: Evolution model (DNA or protein)\nseq1::Union{LongDNA{4},LongAA}: First sequence  \nseq2::Union{LongDNA{4},LongAA}: Second sequence\nt::Float64: Evolution time (branch length) between sequences\njoint::Bool=false: If true, compute joint likelihood including Ï€ terms\n\nReturns\n\nFloat64: Log-probability (conditional or joint)\n\nExample\n\nmodel = create_model(LGModel, 1.0, normalize=true)\nseq1 = aa\"EVQLVES\"\nseq2 = aa\"EVQLIES\"\n\n# Conditional: P(seq2 | seq1, t) - use for ML distance estimation\nL_cond = sequence_likelihood(model, seq1, seq2, 0.1)\n\n# Joint: P(seq1, seq2 | t) - use for model comparison\nL_joint = sequence_likelihood(model, seq1, seq2, 0.1, joint=true)\n\nWhen to use each\n\nConditional (joint=false): ML distance estimation (Ï€ doesn't affect argmax over t)\nJoint (joint=true): Model comparison, Bayesian inference, proper likelihood values\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.sequence_likelihood-Tuple{PartitionModel, Union{BioSequences.LongAA, BioSequences.LongDNA{4}, BioSequences.LongNuc{4, BioSequences.DNAAlphabet{4}}}, Union{BioSequences.LongAA, BioSequences.LongDNA{4}, BioSequences.LongNuc{4, BioSequences.DNAAlphabet{4}}}, Float64}","page":"Home","title":"EvolutionModels.sequence_likelihood","text":"sequence_likelihood(model::PartitionModel, seq1, seq2, t::Float64; joint::Bool=false)\n\nCompute likelihood using region-specific models.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.stationary_frequencies-Tuple{Model}","page":"Home","title":"EvolutionModels.stationary_frequencies","text":"Get the stationary distribution Ï€.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.symbol_index-Tuple{BioSymbols.DNA, DNAType}","page":"Home","title":"EvolutionModels.symbol_index","text":"Get index of a symbol in the canonical ordering\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.transition_probability_matrix-Tuple{GammaRateModel, Float64, Int64}","page":"Home","title":"EvolutionModels.transition_probability_matrix","text":"transition_probability_matrix(model::GammaRateModel, t::Float64, rate_category::Int)\n\nCompute P(t) for a specific rate category.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.transition_probability_matrix-Tuple{Model, Float64}","page":"Home","title":"EvolutionModels.transition_probability_matrix","text":"Compute transition probability matrix P(t) = exp(Qt).\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.validate_frequencies-Union{Tuple{S}, Tuple{Vector{Float64}, S}} where S<:SequenceType","page":"Home","title":"EvolutionModels.validate_frequencies","text":"Validate frequencies vector\n\n\n\n\n\n","category":"method"}]
}
