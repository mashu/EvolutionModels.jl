var documenterSearchIndex = {"docs":
[{"location":"guide/#Practical-Guide","page":"Theoretical Guide","title":"Practical Guide","text":"This guide covers model selection, interpretation of results, and practical applications for antibody sequence analysis.","category":"section"},{"location":"guide/#Model-Selection","page":"Theoretical Guide","title":"Model Selection","text":"","category":"section"},{"location":"guide/#DNA-Models","page":"Theoretical Guide","title":"DNA Models","text":"","category":"section"},{"location":"guide/#JC69-(Jukes-Cantor-1969)","page":"Theoretical Guide","title":"JC69 (Jukes-Cantor 1969)","text":"The simplest nucleotide substitution model with equal rates between all bases and uniform base frequencies (œÄ = 0.25 for all).\n\nUse when:\n\nQuick distance estimates are needed\nSequences are closely related (low divergence)\nBase composition is approximately uniform\n\nmodel = create_model(JC69Model, 1.0, normalize=true)","category":"section"},{"location":"guide/#HKY85-(Hasegawa-Kishino-Yano-1985)","page":"Theoretical Guide","title":"HKY85 (Hasegawa-Kishino-Yano 1985)","text":"Extends JC69 with a transition/transversion rate ratio (Œ∫) and arbitrary base frequencies.\n\nUse when:\n\nTransition bias is expected (common in most biological data)\nBase frequencies differ from uniform\nAnalyzing somatic hypermutation in antibodies (Œ∫ ‚âà 2-3 captures AID bias)\n\nœÄ = [0.25, 0.25, 0.25, 0.25]  # A, C, G, T frequencies\nŒ∫ = 2.5  # Transition/transversion ratio\nmodel = create_model(HKY85Model, 1.0, œÄ, Œ∫, normalize=true)","category":"section"},{"location":"guide/#GTR-(General-Time-Reversible)","page":"Theoretical Guide","title":"GTR (General Time-Reversible)","text":"The most general neutral, reversible model with 6 exchangeability parameters and arbitrary base frequencies.\n\nUse when:\n\nFull flexibility is required\nModel selection indicates simpler models are inadequate\nSufficient data exists to estimate additional parameters\n\nœÄ = [0.3, 0.2, 0.2, 0.3]\nrates = [0.0 1.0 2.0 1.0;\n         1.0 0.0 1.0 2.0;\n         2.0 1.0 0.0 1.0;\n         1.0 2.0 1.0 0.0]\nmodel = create_model(GTRModel, 1.0, œÄ, rates, normalize=true)","category":"section"},{"location":"guide/#Protein-Models","page":"Theoretical Guide","title":"Protein Models","text":"","category":"section"},{"location":"guide/#LG-(Le-Gascuel-2008)","page":"Theoretical Guide","title":"LG (Le-Gascuel 2008)","text":"Empirical amino acid substitution matrix derived from 3,912 protein families. Generally the recommended default for protein sequence analysis.\n\nUse when:\n\nAnalyzing protein sequences (default choice)\nAntibody VH/VL region analysis\nGeneral protein evolution studies\n\nmodel = create_model(LGModel, 1.0, normalize=true)","category":"section"},{"location":"guide/#WAG-(Whelan-Goldman-2001)","page":"Theoretical Guide","title":"WAG (Whelan-Goldman 2001)","text":"Earlier empirical matrix from 182 protein families. Provides an alternative to LG with slightly different exchangeabilities.\n\nUse when:\n\nAlternative to LG for comparison\nConsistency with older analyses that used WAG\n\nmodel = create_model(WAGModel, 1.0, normalize=true)","category":"section"},{"location":"guide/#Recommended-Defaults","page":"Theoretical Guide","title":"Recommended Defaults","text":"Data Type Model Configuration\nProtein sequences LG create_model(LGModel, 1.0, normalize=true)\nDNA (general) HKY85 create_model(HKY85Model, 1.0, œÄ, 2.0, normalize=true)\nDNA (quick estimate) JC69 create_model(JC69Model, 1.0, normalize=true)\n\n","category":"section"},{"location":"guide/#Understanding-Distances","page":"Theoretical Guide","title":"Understanding Distances","text":"","category":"section"},{"location":"guide/#Normalized-vs-Unnormalized-Models","page":"Theoretical Guide","title":"Normalized vs Unnormalized Models","text":"The normalize=true option scales the rate matrix so that the expected number of substitutions per unit time equals 1. This makes distances directly interpretable.\n\n# Normalized: distance = expected substitutions per site\nmodel = create_model(LGModel, 1.0, normalize=true)\n\n# Verify normalization\nrate = expected_substitution_rate(model.Q, model.œÄ)  # ‚âà 1.0\n\nWith normalization: A distance of 0.1 means approximately 10% of sites have experienced at least one substitution.\n\nWithout normalization: Distances depend on the model's inherent scaling and cannot be directly compared across models.","category":"section"},{"location":"guide/#Distance-Interpretation","page":"Theoretical Guide","title":"Distance Interpretation","text":"Distance Sequence Divergence Typical Scenario\n0.00-0.01 Nearly identical Recent duplication, sequencing of same clone\n0.01-0.05 Low divergence Closely related sequences, early divergence\n0.05-0.15 Moderate divergence Typical within-species variation\n0.15-0.50 High divergence Between-species comparisons\n>0.50 Saturated Multiple substitutions obscure signal","category":"section"},{"location":"guide/#Handling-Saturated-Sequences","page":"Theoretical Guide","title":"Handling Saturated Sequences","text":"For highly divergent sequences (p-distance > 0.7), distance estimates become unreliable due to multiple substitutions at the same site. Consider:\n\nUsing protein sequences instead of DNA (larger alphabet reduces saturation)\nFocusing on conserved regions\nInterpreting distances with caution\n\n","category":"section"},{"location":"guide/#Antibody-Sequence-Analysis","page":"Theoretical Guide","title":"Antibody Sequence Analysis","text":"","category":"section"},{"location":"guide/#Measuring-Somatic-Hypermutation","page":"Theoretical Guide","title":"Measuring Somatic Hypermutation","text":"Evolutionary distance between germline and mutated antibody sequences quantifies the extent of somatic hypermutation (SHM).\n\nusing EvolutionModels\nusing BioSequences\nusing Optim\n\nmodel = create_model(LGModel, 1.0, normalize=true)\n\ngermline = aa\"EVQLVESGGGLVQPGGSLRLSCAASGFTFSSYAMSWVRQAPGKGLEWVSAISGSGGSTYYADSVKGRFTISRDNSKNTLYLQMNSLRAEDTAVYYCAK\"\nmutated  = aa\"EVQLVESGGGLVQPGRSLRLSCAASGFTFSSYWMSWVRQAPGKGLEWVANIKQDGSEKYYVDSVKGRFTISRDNAKNSLYLQMNSLRAEDTAVYYCAK\"\n\n# Maximum likelihood distance estimation\nneg_ll(t) = t < 0 ? Inf : -sequence_likelihood(model, germline, mutated, t)\nresult = optimize(neg_ll, 0.0, 1.0, Brent())\ndistance = Optim.minimizer(result)\n\nprintln(\"SHM distance: $(round(distance, digits=4))\")","category":"section"},{"location":"guide/#SHM-Distance-Interpretation","page":"Theoretical Guide","title":"SHM Distance Interpretation","text":"Distance SHM Level Biological Context\n0.00-0.02 Minimal Near-germline, naive B cell\n0.02-0.05 Low Early memory, limited affinity maturation\n0.05-0.10 Moderate Typical memory B cell\n0.10-0.15 High Extensively matured, long-lived plasma cell\n>0.15 Very high Chronic infection, autoimmune conditions","category":"section"},{"location":"guide/#B-Cell-Lineage-Analysis","page":"Theoretical Guide","title":"B Cell Lineage Analysis","text":"Computing pairwise distances for clonally-related sequences enables lineage reconstruction and subclone identification.\n\nusing EvolutionModels\nusing FASTX\nusing Optim\n\n# Load aligned sequences from a B cell lineage\naln = read_alignment(\"bcell_lineage.fasta\")\n\nmodel = create_model(LGModel, 1.0, normalize=true)\nresult = compute_distances(model, aln)\n\n# Distance matrix for downstream analysis\nD = result.distances\nlabels = result.labels\n\nprint_distance_matrix(result, digits=3)\n\nThe resulting distance matrix can be used for:\n\nHierarchical clustering to identify subclones\nInput to tree reconstruction algorithms\nQuantifying within-lineage diversity","category":"section"},{"location":"guide/#DNA-Level-Analysis","page":"Theoretical Guide","title":"DNA-Level Analysis","text":"For nucleotide-level analysis capturing SHM transition bias:\n\nusing EvolutionModels\nusing BioSequences\n\n# HKY85 with transition bias typical of AID-mediated SHM\nœÄ = [0.25, 0.25, 0.25, 0.25]\nŒ∫ = 2.5  # Transitions favored over transversions\nmodel = create_model(HKY85Model, 1.0, œÄ, Œ∫, normalize=true)\n\ngermline_nt = dna\"GAGGTGCAGCTGGTGGAGTCTGGGGGAGGCTTGGTACAG\"\nmutated_nt  = dna\"GAGGTGCAGCTGGTGGAGTCTGGGGGAGGCTTGGTGCAG\"\n\n# Compute likelihood at estimated distance\ndistance = 0.05\nll = sequence_likelihood(model, germline_nt, mutated_nt, distance)","category":"section"},{"location":"guide/#Simulating-Sequence-Evolution","page":"Theoretical Guide","title":"Simulating Sequence Evolution","text":"Generate hypothetical evolved sequences for method validation or hypothesis testing:\n\nusing EvolutionModels\nusing BioSequences\nusing Random\n\nRandom.seed!(42)\n\nmodel = create_model(LGModel, 1.0, normalize=true)\ngermline = aa\"EVQLVESGGGLVQPGGSLRLSCAASGFTFSSYAMSWVRQAPGKGLEWVSAISGSGGSTYYADSVKGRFTISRDNSKNTLYLQMNSLRAEDTAVYYCAK\"\n\n# Simulate evolution at different distances\nfor t in [0.02, 0.05, 0.10, 0.15]\n    evolved = evolve_sequence(model, germline, t)\n    n_mut = count(g != e for (g, e) in zip(germline, evolved))\n    println(\"t=$t: $n_mut mutations ($(round(100*n_mut/length(germline), digits=1))%)\")\nend\n\n","category":"section"},{"location":"guide/#Likelihood-Computation","page":"Theoretical Guide","title":"Likelihood Computation","text":"","category":"section"},{"location":"guide/#Conditional-vs-Joint-Likelihood","page":"Theoretical Guide","title":"Conditional vs Joint Likelihood","text":"The sequence_likelihood function supports two modes:\n\nConditional likelihood (default):\n\nlog P(textseq2  textseq1 t) = sum_k=1^L log P(t)_x_1k x_2k\n\nJoint likelihood (joint=true):\n\nlog P(textseq1 textseq2  t) = sum_k=1^L left log pi_x_1k + log P(t)_x_1k x_2k right\n\nmodel = create_model(LGModel, 1.0, normalize=true)\nseq1 = aa\"EVQLVESGGGLVQPGGSLRL\"\nseq2 = aa\"EVQLVESGGGLIQPGGSLRL\"\n\n# Conditional: P(seq2 | seq1, t)\nL_cond = sequence_likelihood(model, seq1, seq2, 0.05)\n\n# Joint: P(seq1, seq2 | t)  \nL_joint = sequence_likelihood(model, seq1, seq2, 0.05, joint=true)","category":"section"},{"location":"guide/#When-Joint-Likelihood-Matters","page":"Theoretical Guide","title":"When Joint Likelihood Matters","text":"","category":"section"},{"location":"guide/#Use-Conditional-(default)-When:","page":"Theoretical Guide","title":"Use Conditional (default) When:","text":"Estimating evolutionary distance between two sequences\n\nThe stationary frequency term ‚àë log(œÄ·µ¢) is constant for fixed sequences regardless of t. Therefore, finding the distance that maximizes likelihood gives the same answer whether you use conditional or joint:\n\n# Both give the same optimal distance\nargmax_t P(seq2|seq1,t) = argmax_t P(seq1,seq2|t)\n\nFor distance estimation, conditional is computationally simpler and equally correct.\n\nComparing likelihoods at different times for the same sequence pair\n\nIf you're asking \"is t=0.05 or t=0.10 more likely for these sequences?\", the œÄ term cancels out in the comparison.","category":"section"},{"location":"guide/#Use-Joint-Likelihood-When:","page":"Theoretical Guide","title":"Use Joint Likelihood When:","text":"Comparing different models\n\nWhen comparing models with different stationary frequencies (e.g., LG vs WAG, or models with estimated œÄ), the joint likelihood is required for proper comparison:\n\nmodel_lg = create_model(LGModel, 1.0, normalize=true)\nmodel_wag = create_model(WAGModel, 1.0, normalize=true)\n\n# WRONG: Conditional doesn't account for different œÄ\nL_lg_cond = sequence_likelihood(model_lg, seq1, seq2, 0.1)\nL_wag_cond = sequence_likelihood(model_wag, seq1, seq2, 0.1)\n\n# CORRECT: Joint includes œÄ contribution\nL_lg_joint = sequence_likelihood(model_lg, seq1, seq2, 0.1, joint=true)\nL_wag_joint = sequence_likelihood(model_wag, seq1, seq2, 0.1, joint=true)\n\n# Model with higher joint likelihood better explains the data\nbetter_model = L_lg_joint > L_wag_joint ? \"LG\" : \"WAG\"\n\nComputing AIC/BIC for model selection\n\nInformation criteria require the actual likelihood, not conditional probability:\n\n# AIC = 2k - 2ln(L) where L is the likelihood\nk = 1  # number of parameters (just distance for empirical models)\nAIC_lg = 2*k - 2*L_lg_joint\nAIC_wag = 2*k - 2*L_wag_joint\n\nBayesian inference\n\nPosterior probabilities require the joint likelihood:\n\n# P(model|data) ‚àù P(data|model) √ó P(model)\n# P(data|model) is the joint likelihood\n\nComparing sequences with different compositions\n\nIf comparing likelihood across different sequence pairs, joint likelihood accounts for how \"probable\" each sequence is under the model's equilibrium:\n\n# Sequence pair A (common amino acids)\nseq1a = aa\"AAAAAAAAA\"\nseq2a = aa\"AAAAAAAAA\"\n\n# Sequence pair B (rare amino acids)  \nseq1b = aa\"WWWWWWWWW\"\nseq2b = aa\"WWWWWWWWW\"\n\n# Conditional treats both equally (identical sequences)\nL_a_cond = sequence_likelihood(model, seq1a, seq2a, 0.01)  # High\nL_b_cond = sequence_likelihood(model, seq1b, seq2b, 0.01)  # High\n\n# Joint reflects that W is rare in natural proteins\nL_a_joint = sequence_likelihood(model, seq1a, seq2a, 0.01, joint=true)\nL_b_joint = sequence_likelihood(model, seq1b, seq2b, 0.01, joint=true)\n# L_a_joint > L_b_joint because A is more common than W","category":"section"},{"location":"guide/#Lineage-Reconstruction-and-Clustering","page":"Theoretical Guide","title":"Lineage Reconstruction and Clustering","text":"For B cell lineage reconstruction or antibody clustering, use conditional likelihood (the default). This is what compute_distances() does internally.\n\nWhen computing pairwise distances for a distance matrix:\n\nEach pair gets its own ML distance estimate\nThe œÄ term doesn't affect which distance is optimal for each pair\nAll distances are in the same units and directly comparable\n\n# Correct approach for lineage/clustering\nmodel = create_model(LGModel, 1.0, normalize=true)\nresult = compute_distances(model, alignment)\nD = result.distances  # Ready for tree building or clustering","category":"section"},{"location":"guide/#Comparing-Models-for-a-Lineage","page":"Theoretical Guide","title":"Comparing Models for a Lineage","text":"If you want to ask \"does LG or WAG better explain my antibody lineage?\", use alignment_likelihood to compute total likelihood over all pairs:\n\nusing EvolutionModels\nusing FASTX\nusing Optim\n\naln = read_alignment(\"lineage.fasta\")\n\nmodel_lg = create_model(LGModel, 1.0, normalize=true)\nmodel_wag = create_model(WAGModel, 1.0, normalize=true)\n\n# Compute total joint log-likelihood for each model\nresult_lg = alignment_likelihood(model_lg, aln)\nresult_wag = alignment_likelihood(model_wag, aln)\n\nprintln(\"LG:  total=$(round(result_lg.total_logL, digits=2)), mean=$(round(result_lg.mean_logL, digits=2))\")\nprintln(\"WAG: total=$(round(result_wag.total_logL, digits=2)), mean=$(round(result_wag.mean_logL, digits=2))\")\nprintln(\"Better model: \", result_lg.total_logL > result_wag.total_logL ? \"LG\" : \"WAG\")\n\nThis answers \"which substitution model better captures the evolutionary patterns in my antibody data?\" - useful when you have lineage-specific amino acid preferences or want to validate model choice.","category":"section"},{"location":"guide/#Summary","page":"Theoretical Guide","title":"Summary","text":"Question Use Reason\n\"What is the evolutionary distance?\" Conditional œÄ doesn't affect optimal t\n\"Distance matrix for clustering/trees?\" Conditional Each pair optimized independently\n\"Which model fits better?\" Joint Must account for different œÄ\n\"Is this sequence pair unusual?\" Joint Accounts for amino acid frequencies\n\"What's the AIC/BIC?\" Joint Information criteria need true likelihood\n\"Posterior probability of model?\" Joint Bayesian inference requirement","category":"section"},{"location":"guide/#Maximum-Likelihood-Distance-Estimation","page":"Theoretical Guide","title":"Maximum Likelihood Distance Estimation","text":"Find the evolutionary distance that maximizes the likelihood:\n\nusing Optim\n\nmodel = create_model(LGModel, 1.0, normalize=true)\nseq1 = aa\"EVQLVESGGGLVQPGGSLRL\"\nseq2 = aa\"EVQLVESGGGLIQPGGSLRL\"\n\nneg_ll(t) = t < 0 ? Inf : -sequence_likelihood(model, seq1, seq2, t)\nresult = optimize(neg_ll, 0.0, 2.0, Brent())\n\nml_distance = Optim.minimizer(result)\nmax_logL = -Optim.minimum(result)","category":"section"},{"location":"guide/#Comparing-Evolutionary-Hypotheses","page":"Theoretical Guide","title":"Comparing Evolutionary Hypotheses","text":"Use likelihood ratios to compare different evolutionary scenarios:\n\nmodel = create_model(LGModel, 1.0, normalize=true)\n\n# Two sequences\nseqA = aa\"EVQLVESGGGLVQPGGSLRL\"\nseqB = aa\"EVQLVESGGGLIQPGGSLRL\"\n\n# Compare hypotheses: recent vs ancient divergence\nL_recent = sequence_likelihood(model, seqA, seqB, 0.02)\nL_ancient = sequence_likelihood(model, seqA, seqB, 0.20)\n\nlog_ratio = L_recent - L_ancient\nprintln(\"Log likelihood ratio: $log_ratio\")\n# Positive = recent divergence more likely\n\n","category":"section"},{"location":"guide/#Limitations-and-Considerations","page":"Theoretical Guide","title":"Limitations and Considerations","text":"","category":"section"},{"location":"guide/#Model-Assumptions","page":"Theoretical Guide","title":"Model Assumptions","text":"All models assume:\n\nSite independence: Each position evolves independently\nTime reversibility: Process is stationary and reversible\nHomogeneous rates: Same process at all sites (no rate variation)\n\nThese assumptions may be violated in biological data, particularly for antibodies where CDR regions experience selection.","category":"section"},{"location":"guide/#Empirical-Models-and-SHM","page":"Theoretical Guide","title":"Empirical Models and SHM","text":"The WAG and LG matrices were derived from germline protein evolution across diverse protein families. Somatic hypermutation has distinct characteristics:\n\nAID-mediated with specific hotspot motifs\nStrong selection during affinity maturation\nRapid timescale (days to weeks vs millions of years)\n\nThe empirical models provide useful approximations but may not perfectly capture SHM patterns. For specialized applications, consider SHM-specific models from the literature.","category":"section"},{"location":"guide/#Gaps-and-Missing-Data","page":"Theoretical Guide","title":"Gaps and Missing Data","text":"Non-standard characters (gaps, ambiguous bases) are excluded from likelihood calculations. Heavily gapped alignments may produce unreliable results. Consider:\n\nQuality filtering before analysis\nAnalyzing gap patterns separately\nUsing alignment-free methods for highly divergent sequences\n\n","category":"section"},{"location":"guide/#References","page":"Theoretical Guide","title":"References","text":"Jukes, T.H. & Cantor, C.R. (1969). Evolution of Protein Molecules. Mammalian Protein Metabolism, 3:21-132.\nHasegawa, M., Kishino, H. & Yano, T. (1985). Dating of the human-ape splitting by a molecular clock of mitochondrial DNA. J Mol Evol, 22:160-174.\nTavar√©, S. (1986). Some probabilistic and statistical problems in the analysis of DNA sequences. Lectures on Mathematics in the Life Sciences, 17:57-86.\nWhelan, S. & Goldman, N. (2001). A general empirical model of protein evolution derived from multiple protein families using a maximum-likelihood approach. Mol Biol Evol, 18:691-699.\nLe, S.Q. & Gascuel, O. (2008). An improved general amino acid replacement matrix. Mol Biol Evol, 25:1307-1320.\nYang, Z. (2014). Molecular Evolution: A Statistical Approach. Oxford University Press.\nYaari, G. & Kleinstein, S.H. (2015). Practical guidelines for B-cell receptor repertoire sequencing analysis. Genome Med, 7:121.","category":"section"},{"location":"#EvolutionModels","page":"Home","title":"EvolutionModels","text":"Documentation for EvolutionModels.\n\nüöß Work in Progress: This package is under active development.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"EvolutionModels.jl implements continuous-time Markov chain (CTMC) models for molecular sequence evolution. The package supports:\n\nDNA Models: JC69, HKY85, GTR\nProtein Models: WAG, LG (empirical amino acid substitution matrices)\nSimulation: Evolve sequences along branches\nLikelihood: Compute probabilities of sequence pairs\nDistance Estimation: ML-based pairwise evolutionary distances","category":"section"},{"location":"#Mathematical-Foundation","page":"Home","title":"Mathematical Foundation","text":"","category":"section"},{"location":"#Continuous-Time-Markov-Chains","page":"Home","title":"Continuous-Time Markov Chains","text":"Sequence evolution is modeled as a continuous-time Markov process on the state space of nucleotides (A, C, G, T) or amino acids. The key mathematical objects are:\n\nQ (Rate Matrix): Instantaneous rates of change, with Q·µ¢‚±º ‚â• 0 for i ‚â† j and row sums = 0\nP(t) = exp(Qt): Transition probability matrix for evolution over time t\nœÄ (Stationary Distribution): Equilibrium frequencies satisfying œÄQ = 0\n\nFor time-reversible models, detailed balance holds:\n\npi_i Q_ij = pi_j Q_ji\n\nThis is achieved by constructing Q from symmetric exchangeabilities S:\n\nQ_ij = S_ij cdot pi_j quad textfor  i neq j","category":"section"},{"location":"#Rate-Normalization","page":"Home","title":"Rate Normalization","text":"By default, the overall evolutionary rate depends on Œº. Use normalize=true to scale Q so that:\n\n-sum_i pi_i Q_ii = 1\n\nThis means branch length t directly represents the expected number of substitutions per site.","category":"section"},{"location":"#DNA-Substitution-Models","page":"Home","title":"DNA Substitution Models","text":"","category":"section"},{"location":"#Jukes-Cantor-(JC69)","page":"Home","title":"Jukes-Cantor (JC69)","text":"The simplest model assuming:\n\nEqual base frequencies: œÄA = œÄC = œÄG = œÄT = 1/4\nEqual substitution rates between all nucleotides\n\nRate matrix:\n\nQ = beginpmatrix\n-3alpha  alpha  alpha  alpha \nalpha  -3alpha  alpha  alpha \nalpha  alpha  -3alpha  alpha \nalpha  alpha  alpha  -3alpha\nendpmatrix\n\nwhere Œ± = Œº/4 (or Œ± = 1/3 when normalized)","category":"section"},{"location":"#HKY85-Model","page":"Home","title":"HKY85 Model","text":"Extends JC69 with:\n\nArbitrary base frequencies (œÄA, œÄC, œÄG, œÄT)\nDifferent rates for transitions (A‚ÜîG, C‚ÜîT) vs transversions\nRate ratio Œ∫ between transitions and transversions\n\nq_ij = begincases\nmukappapi_j  textfor transitions \nmupi_j  textfor transversions \n-sum_kneq i q_ik  textfor  i = j\nendcases","category":"section"},{"location":"#General-Time-Reversible-(GTR)","page":"Home","title":"General Time-Reversible (GTR)","text":"Most general neutral, reversible model:\n\nArbitrary base frequencies œÄ\nSix exchangeability parameters (rAC, rAG, rAT, rCG, rCT, rGT)\nSatisfies detailed balance","category":"section"},{"location":"#Protein-Substitution-Models","page":"Home","title":"Protein Substitution Models","text":"","category":"section"},{"location":"#WAG-Model","page":"Home","title":"WAG Model","text":"Empirical amino acid substitution matrix derived from 182 protein families (Whelan & Goldman, 2001). Provides both exchangeabilities and equilibrium frequencies estimated via maximum likelihood.","category":"section"},{"location":"#LG-Model","page":"Home","title":"LG Model","text":"Improved empirical matrix from 3,912 protein families (Le & Gascuel, 2008). Generally recommended for modern protein sequence analysis.","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"#Creating-Models","page":"Home","title":"Creating Models","text":"using EvolutionModels\nusing BioSequences\n\n# JC69 - simplest DNA model\nmodel_jc = create_model(JC69Model, 1.0)\n\n# JC69 normalized (1 expected substitution per unit time)\nmodel_jc_norm = create_model(JC69Model, 1.0, normalize=true)\n\n# HKY85 with custom frequencies and transition bias\nœÄ = [0.3, 0.2, 0.2, 0.3]  # A,C,G,T\nŒ∫ = 2.0  # transitions 2√ó faster than transversions\nmodel_hky = create_model(HKY85Model, 1.0, œÄ, Œ∫, normalize=true)\n\n# GTR with full parameterization\nrates = [0.0 1.0 2.0 1.0;\n         1.0 0.0 1.0 2.0;\n         2.0 1.0 0.0 1.0;\n         1.0 2.0 1.0 0.0]\nmodel_gtr = create_model(GTRModel, 1.0, œÄ, rates, normalize=true)\n\n# Protein models\nmodel_wag = create_model(WAGModel, 1.0, normalize=true)\nmodel_lg = create_model(LGModel, 1.0, normalize=true)","category":"section"},{"location":"#Sequence-Evolution-Simulation","page":"Home","title":"Sequence Evolution Simulation","text":"# DNA evolution\nmodel = create_model(JC69Model, 1.0, normalize=true)\nseq = dna\"ATCGATCGATCGATCG\"\nevolved = evolve_sequence(model, seq, 0.1)  # t=0.1 expected subs/site\n\n# Protein evolution\nmodel_aa = create_model(LGModel, 1.0, normalize=true)\nprotein = aa\"EVQLVESGGGLVQPGGSLRL\"\nevolved_aa = evolve_sequence(model_aa, protein, 0.1)","category":"section"},{"location":"#Likelihood-Computation","page":"Home","title":"Likelihood Computation","text":"model = create_model(JC69Model, 1.0, normalize=true)\nseq1 = dna\"ATCGATCG\"\nseq2 = dna\"ATTGATCG\"\n\n# Compute log P(seq2 | seq1, t)\nlogL = sequence_likelihood(model, seq1, seq2, 0.1)","category":"section"},{"location":"#Distance-Matrix-Computation","page":"Home","title":"Distance Matrix Computation","text":"Requires FASTX.jl and Optim.jl:\n\nusing EvolutionModels\nusing FASTX\nusing Optim\n\n# Read alignment\naln = read_alignment(\"sequences.fasta\")\n\n# Compute pairwise distances\nmodel = create_model(JC69Model, 1.0, normalize=true)\nresult = compute_distances(model, aln)\n\n# Access results\nD = result.distances  # Distance matrix\nlabels = result.labels  # Sequence names","category":"section"},{"location":"#Antibody-Sequence-Analysis","page":"Home","title":"Antibody Sequence Analysis","text":"EvolutionModels.jl is well-suited for analyzing antibody evolution, including somatic hypermutation and B cell lineage analysis.","category":"section"},{"location":"#Analyzing-VH-Region-Evolution","page":"Home","title":"Analyzing VH Region Evolution","text":"using EvolutionModels\nusing BioSequences\n\n# Use LG model for protein-level analysis\nmodel = create_model(LGModel, 1.0, normalize=true)\n\n# Germline VH sequence (IGHV3-23*01)\ngermline = aa\"EVQLVESGGGLVQPGGSLRLSCAASGFTFSSYAMSWVRQAPGKGLEWVSAISGSGGSTYYADSVKGRFTISRDNSKNTLYLQMNSLRAEDTAVYYCAK\"\n\n# Somatically mutated antibody\nmutated = aa\"EVQLVESGGGLVQPGRSLRLSCAASGFTFSSYWMSWVRQAPGKGLEWVANIKQDGSEKYYVDSVKGRFTISRDNAKNSLYLQMNSLRAEDTAVYYCAK\"\n\n# Compute likelihood at different evolutionary distances\nfor t in [0.01, 0.05, 0.10, 0.20]\n    ll = sequence_likelihood(model, germline, mutated, t)\n    println(\"t=$t: log-likelihood = $(round(ll, digits=2))\")\nend","category":"section"},{"location":"#Simulating-Somatic-Hypermutation","page":"Home","title":"Simulating Somatic Hypermutation","text":"using EvolutionModels\nusing BioSequences\nusing Random\n\nRandom.seed!(42)\n\nmodel = create_model(LGModel, 1.0, normalize=true)\n\n# Germline antibody\ngermline = aa\"EVQLVESGGGLVQPGGSLRLSCAASGFTFSSYAMSWVRQAPGKGLEWVSAISGSGGSTYYADSVKGRFTISRDNSKNTLYLQMNSLRAEDTAVYYCAK\"\n\n# Simulate evolution at increasing distances\nprintln(\"Simulating somatic hypermutation:\")\nfor t in [0.02, 0.05, 0.10, 0.15]\n    evolved = evolve_sequence(model, germline, t)\n    n_mut = count(g != e for (g, e) in zip(germline, evolved))\n    pct = round(100 * n_mut / length(germline), digits=1)\n    println(\"  t=$t: $n_mut mutations ($pct%)\")\nend","category":"section"},{"location":"#DNA-Level-Analysis-with-Transition-Bias","page":"Home","title":"DNA-Level Analysis with Transition Bias","text":"Somatic hypermutation shows bias toward transitions. Model this with HKY85:\n\nusing EvolutionModels\nusing BioSequences\n\n# HKY85 with transition bias (Œ∫ > 1)\nœÄ = [0.25, 0.25, 0.25, 0.25]\nŒ∫ = 2.5  # Transitions favored\nmodel = create_model(HKY85Model, 1.0, œÄ, Œ∫, normalize=true)\n\n# VH nucleotide sequence\ngermline_nt = dna\"GAGGTGCAGCTGGTGGAGTCTGGGGGAGGCTTGGTACAGCCTGGGGGGTCCCTGAGACTCTCCTGTGCAGCCTCT\"\n\n# Simulate mutations\nmutated_nt = evolve_sequence(model, germline_nt, 0.05)\n\n# Analyze mutation spectrum\ntransitions = 0\ntransversions = 0\nfor (g, m) in zip(germline_nt, mutated_nt)\n    if g != m\n        if (g == DNA_A && m == DNA_G) || (g == DNA_G && m == DNA_A) ||\n           (g == DNA_C && m == DNA_T) || (g == DNA_T && m == DNA_C)\n            transitions += 1\n        else\n            transversions += 1\n        end\n    end\nend\nprintln(\"Transitions: $transitions, Transversions: $transversions\")\nprintln(\"Ti/Tv ratio: $(round(transitions/max(transversions,1), digits=2))\")","category":"section"},{"location":"#B-Cell-Lineage-Distance-Matrix","page":"Home","title":"B Cell Lineage Distance Matrix","text":"using EvolutionModels\nusing FASTX\nusing Optim\n\n# Read aligned antibody sequences from a B cell lineage\n# (germline + clonally-related sequences)\naln = read_alignment(\"bcell_lineage.fasta\")\n\n# Compute evolutionary distances\nmodel = create_model(WAGModel, 1.0, normalize=true)\nresult = compute_distances(model, aln)\n\n# Print formatted distance matrix\nprint_distance_matrix(result)\n\n# Distances can be used for:\n# - Phylogenetic tree reconstruction (e.g., with Phylogenetics.jl)\n# - Hierarchical clustering\n# - Identifying clonal relationships","category":"section"},{"location":"#Interpreting-Distances-for-Antibodies","page":"Home","title":"Interpreting Distances for Antibodies","text":"When using normalized models, the evolutionary distance t represents expected amino acid substitutions per site:\n\nDistance (t) Interpretation\n0.01-0.03 Low SHM, early in affinity maturation\n0.05-0.10 Moderate SHM, typical memory B cell\n0.10-0.20 High SHM, extensively mutated\n> 0.20 Very high mutation load","category":"section"},{"location":"#Model-Comparison","page":"Home","title":"Model Comparison","text":"Model States Parameters Use Case\nJC69 DNA (4) 1 (Œº) Quick estimates, equal rates\nHKY85 DNA (4) 4+Œ∫ Transition/transversion bias\nGTR DNA (4) 4+6 Full flexibility\nWAG Protein (20) 1 (Œº) General protein evolution\nLG Protein (20) 1 (Œº) Modern protein analysis","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#EvolutionModels.DNAModel","page":"Home","title":"EvolutionModels.DNAModel","text":"DNAModel <: EvolutionModel\n\nAbstract type for DNA evolution models.\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.EvolutionModel","page":"Home","title":"EvolutionModels.EvolutionModel","text":"EvolutionModel\n\nAbstract type for all molecular evolution models.\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.Model","page":"Home","title":"EvolutionModels.Model","text":"Model{S<:SequenceType}\n\nConcrete implementation of an evolution model.\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.ProteinModel","page":"Home","title":"EvolutionModels.ProteinModel","text":"ProteinModel <: EvolutionModel\n\nAbstract type for protein evolution models.\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.SequenceType","page":"Home","title":"EvolutionModels.SequenceType","text":"SequenceType\n\nAbstract type for sequence alphabets (DNA or Protein).\n\n\n\n\n\n","category":"type"},{"location":"#EvolutionModels.compute_q_matrix-Tuple{Matrix{Float64}, LinearAlgebra.Diagonal{Float64, V} where V<:AbstractVector{Float64}}","page":"Home","title":"EvolutionModels.compute_q_matrix","text":"Compute Q matrix (generator matrix) from R and P.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_model-Tuple{Type{GTRModel}, Float64, Vector{Float64}, Matrix{Float64}}","page":"Home","title":"EvolutionModels.create_model","text":"create_model(::Type{GTRModel}, Œº::Float64, œÄ::Vector{Float64}, rates::Matrix{Float64}; normalize::Bool=false) -> Model{DNAType}\n\nCreate a General Time-Reversible (GTR) model of DNA evolution.\n\nThe GTR model is the most general neutral, independent sites, reversible model:\n\nArbitrary base frequencies œÄ\nArbitrary symmetric rate matrix\nSatisfies detailed balance: œÄ·µ¢q·µ¢‚±º = œÄ‚±ºq‚±º·µ¢\n\nArguments\n\nŒº::Float64: Overall mutation rate scaling factor (must be positive)\nœÄ::Vector{Float64}: Vector of base frequencies [œÄA, œÄC, œÄG, œÄT], must sum to 1\nrates::Matrix{Float64}: 4√ó4 symmetric matrix of relative substitution rates\nnormalize::Bool=false: If true, normalize Q so expected substitutions per unit time = 1\n\nReturns\n\nModel{DNAType}: A GTR model with rate matrix Q = ŒºR‚ãÖdiag(œÄ) where:\nR is the symmetric rate matrix\nq·µ¢‚±º = Œºr·µ¢‚±ºœÄ‚±º for i ‚â† j\nq·µ¢·µ¢ = -‚àë‚±º‚â†·µ¢ q·µ¢‚±º\n\nExample\n\n# Create GTR model with custom rates\nœÄ = [0.3, 0.2, 0.2, 0.3]  # Base frequencies\nrates = [0.0 1.0 2.0 1.0;  # Symmetric rate matrix\n         1.0 0.0 1.0 2.0;\n         2.0 1.0 0.0 1.0;\n         1.0 2.0 1.0 0.0]\nmodel = create_model(GTRModel, 0.1, œÄ, rates)\n\n# Create normalized model\nmodel_norm = create_model(GTRModel, 1.0, œÄ, rates, normalize=true)\n\nReferences\n\nTavar√©, S. (1986). Some probabilistic and statistical problems in the analysis of DNA sequences. Lectures on Mathematics in the Life Sciences, 17:57-86.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_model-Tuple{Type{HKY85Model}, Float64, Vector{Float64}, Float64}","page":"Home","title":"EvolutionModels.create_model","text":"create_model(::Type{HKY85Model}, Œº::Float64, œÄ::Vector{Float64}, Œ∫::Float64; normalize::Bool=false) -> Model{DNAType}\n\nCreate a Hasegawa-Kishino-Yano (1985) model of DNA evolution.\n\nThe HKY85 model features:\n\nArbitrary base frequencies œÄ\nDifferent rates for transitions (A‚ÜîG, C‚ÜîT) vs transversions\nRate ratio Œ∫ between transitions and transversions\n\nArguments\n\nŒº::Float64: Overall mutation rate scaling factor (must be positive)\nœÄ::Vector{Float64}: Vector of base frequencies [œÄA, œÄC, œÄG, œÄT], must sum to 1\nŒ∫::Float64: Transition/transversion rate ratio (must be positive)\nnormalize::Bool=false: If true, normalize Q so expected substitutions per unit time = 1\n\nReturns\n\nModel{DNAType}: An HKY85 model with rate matrix Q where:\nq·µ¢‚±º = ŒºŒ∫œÄ‚±º for transitions\nq·µ¢‚±º = ŒºœÄ‚±º for transversions\nq·µ¢·µ¢ = -‚àë‚±º‚â†·µ¢ q·µ¢‚±º\n\nExample\n\n# Create HKY85 model with unequal base frequencies\nœÄ = [0.3, 0.2, 0.2, 0.3]  # A,C,G,T frequencies\nmodel = create_model(HKY85Model, 0.1, œÄ, 2.0)  # Œ∫=2 means transitions occur 2√ó faster\n\n# Create normalized model\nmodel_norm = create_model(HKY85Model, 1.0, œÄ, 2.0, normalize=true)\n\nReferences\n\nHasegawa, M., Kishino, H., and Yano, T. (1985). Dating of the human-ape splitting by a molecular clock of mitochondrial DNA. J. Mol. Evol., 22(2):160-174.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_model-Tuple{Type{JC69Model}, Float64}","page":"Home","title":"EvolutionModels.create_model","text":"create_model(::Type{JC69Model}, Œº::Float64; normalize::Bool=false) -> Model{DNAType}\n\nCreate a Jukes-Cantor (1969) model of DNA evolution.\n\nThe JC69 model assumes:\n\nEqual base frequencies (œÄ = 0.25 for all bases)\nEqual substitution rates between all nucleotides\nSingle parameter Œº controlling overall mutation rate\n\nArguments\n\nŒº::Float64: Overall mutation rate scaling factor (must be positive)\nnormalize::Bool=false: If true, normalize Q so expected substitutions per unit time = 1\n\nReturns\n\nModel{DNAType}: A JC69 model with rate matrix Q where:\nq·µ¢‚±º = Œº/4 for i ‚â† j (off-diagonal elements)  \nq·µ¢·µ¢ = -3Œº/4 (diagonal elements)\nIf normalized: q·µ¢‚±º = 1/3 for i ‚â† j, q·µ¢·µ¢ = -1\n\nExample\n\n# Create JC69 model with rate 0.1\nmodel = create_model(JC69Model, 0.1)\n\n# Create normalized model (1 expected substitution per unit time)\nmodel_norm = create_model(JC69Model, 1.0, normalize=true)\n\n# Access model properties\nœÄ = stationary_frequencies(model)  # All 0.25\nR = rate_matrix(model)  # Symmetric rate matrix\n\nReferences\n\nJukes, T.H. and Cantor, C.R. (1969). Evolution of Protein Molecules.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_model-Tuple{Type{LGModel}, Float64}","page":"Home","title":"EvolutionModels.create_model","text":"create_model(::Type{LGModel}, Œº::Float64; normalize::Bool=false)\n\nCreate an LG (Le-Gascuel) protein evolution model with specified rate scaling factor Œº. Returns a Model{ProteinType} with empirical substitution rates and frequencies.\n\nThe LG model is derived from 3,912 protein families using maximum likelihood methods, improving upon previous models by incorporating rate variation across sites. The amino acid order follows STANDARD_AA: A R N D C Q E G H I L K M F P S T W Y V\n\nCitation\n\nLe, S. Q., & Gascuel, O. (2008). An improved general amino acid replacement matrix. Molecular Biology and Evolution, 25(7), 1307-1320. DOI: 10.1093/molbev/msn067\n\nArguments\n\nŒº::Float64: Rate scaling factor (must be positive)\nnormalize::Bool=false: If true, normalize Q so expected substitutions per unit time = 1\n\nReturns\n\nModel{ProteinType}: Configured LG model\n\nExample\n\n# Create normalized LG model for antibody analysis\nmodel = create_model(LGModel, 1.0, normalize=true)\n\n# Compute evolutionary distance between antibody sequences\nseq1 = aa\"EVQLVESGGGLVQPGGSLRLSCAAS\"\nseq2 = aa\"EVQLVESGGGLVQPGRSLRLSCAAS\"\nlogL = sequence_likelihood(model, seq1, seq2, 0.05)\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.create_model-Tuple{Type{WAGModel}, Float64}","page":"Home","title":"EvolutionModels.create_model","text":"create_model(::Type{WAGModel}, Œº::Float64; normalize::Bool=false)\n\nCreate a WAG (Whelan And Goldman) protein evolution model with specified rate scaling factor Œº. Returns a Model{ProteinType} with empirical substitution rates and frequencies.\n\nThe WAG model is derived from 182 protein families using maximum likelihood methods, providing both substitution rates and equilibrium frequencies estimated from the data. The amino acid order follows STANDARD_AA: A R N D C Q E G H I L K M F P S T W Y V\n\nCitation\n\nWhelan, S., & Goldman, N. (2001). A general empirical model of protein evolution derived from multiple protein families using a maximum-likelihood approach. Molecular Biology and Evolution, 18(5), 691-699. DOI: 10.1093/oxfordjournals.molbev.a003851\n\nArguments\n\nŒº::Float64: Rate scaling factor (must be positive)\nnormalize::Bool=false: If true, normalize Q so expected substitutions per unit time = 1\n\nReturns\n\nModel{ProteinType}: Configured WAG model\n\nExample\n\n# Create WAG model for antibody sequence analysis\nmodel = create_model(WAGModel, 1.0, normalize=true)\n\n# Evolve an antibody variable region sequence\nseq = aa\"EVQLVESGGGLVQPGGSLRLSCAAS\"\nevolved = evolve_sequence(model, seq, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.evolve_sequence-Tuple{Model{DNAType}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, Float64}","page":"Home","title":"EvolutionModels.evolve_sequence","text":"evolve_sequence(model::Model{DNAType}, seq::LongDNA{4}, t::Float64; \n               rng::AbstractRNG=Random.GLOBAL_RNG) -> LongDNA{4}\n\nSimulate DNA sequence evolution under a continuous-time Markov model for time t.\n\nThe function implements the following process:\n\nComputes transition probability matrix P(t) = exp(Qt)\nFor each site, samples new nucleotide from the probability distribution given by the corresponding row of P(t)\nPreserves non-standard nucleotides (gaps, ambiguous bases) unchanged\n\nArguments\n\nmodel::Model{DNAType}: DNA evolution model (JC69, HKY85, or GTR)\nseq::LongDNA{4}: Input DNA sequence\nt::Float64: Evolution time (branch length)\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator\n\nReturns\n\nLongDNA{4}: Evolved DNA sequence of the same length as input\n\nExample\n\n# Create model and evolve sequence\nmodel = create_model(JC69Model, 0.1)\nseq = dna\"ATCG\"\nevolved = evolve_sequence(model, seq, 1.0)\n\n# Use specific RNG for reproducibility\nrng = MersenneTwister(42)\nevolved = evolve_sequence(model, seq, 1.0, rng=rng)\n\nNote: For very small t, few changes are expected. As t‚Üí‚àû, nucleotide frequencies approach the model's stationary distribution œÄ.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.evolve_sequence-Tuple{Model{ProteinType}, BioSequences.LongAA, Float64}","page":"Home","title":"EvolutionModels.evolve_sequence","text":"evolve_sequence(model::Model{ProteinType}, seq::LongAA, t::Float64; \n               rng::AbstractRNG=Random.GLOBAL_RNG) -> LongAA\n\nSimulate protein sequence evolution under empirical amino acid substitution models.\n\nThe function implements the following process:\n\nComputes transition probability matrix P(t) = exp(Qt)\nFor each site, samples new amino acid from the probability distribution given by the corresponding row of P(t)\nPreserves non-standard amino acids (gaps, ambiguous residues) unchanged\n\nArguments\n\nmodel::Model{ProteinType}: Protein evolution model (WAG or LG)\nseq::LongAA: Input amino acid sequence\nt::Float64: Evolution time (branch length)\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator\n\nReturns\n\nLongAA: Evolved amino acid sequence of the same length as input\n\nExample\n\n# Create model and evolve sequence\nmodel = create_model(WAGModel, 0.1)\nseq = aa\"ARND\"\nevolved = evolve_sequence(model, seq, 1.0)\n\nNote: The empirical models (WAG, LG) use pre-computed rate matrices derived from large protein alignments, representing \"average\" evolutionary patterns.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.expected_substitution_rate-Tuple{Matrix{Float64}, Vector{Float64}}","page":"Home","title":"EvolutionModels.expected_substitution_rate","text":"expected_substitution_rate(Q::Matrix{Float64}, œÄ::Vector{Float64}) -> Float64\n\nCompute the expected number of substitutions per unit time for a rate matrix Q with stationary distribution œÄ.\n\nFormula\n\nbeta = -sum_i pi_i Q_ii\n\nArguments\n\nQ::Matrix{Float64}: Rate matrix\nœÄ::Vector{Float64}: Stationary frequencies\n\nReturns\n\nFloat64: Expected substitutions per unit time\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.is_transition-Tuple{BioSymbols.DNA, BioSymbols.DNA}","page":"Home","title":"EvolutionModels.is_transition","text":"Check if two symbols are transitions (A‚ÜîG or C‚ÜîT)\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.load_empirical_data-Tuple{String}","page":"Home","title":"EvolutionModels.load_empirical_data","text":"load_empirical_data(filepath::String)\n\nLoad empirical substitution matrix and frequencies from a data file. Internal helper function for specific model loaders.\n\nFormat\n\nFile should contain:\n\nLines 1-19: Lower triangular elements of the 20√ó20 substitution rate matrix\nLine 22: Vector of 20 equilibrium frequencies\n\nThe amino acid order follows STANDARD_AA: A R N D C Q E G H I L K M F P S T W Y V\n\nArguments\n\nfilepath::String: Path to the data file\n\nReturns\n\nTuple{Matrix{Float64}, Vector{Float64}}: Rate matrix and frequency vector\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.load_lg_frequencies-Tuple{}","page":"Home","title":"EvolutionModels.load_lg_frequencies","text":"load_lg_frequencies()\n\nLoad LG amino acid frequencies from LG.dat. Returns equilibrium frequencies in STANDARD_AA order.\n\nCitation\n\nLe & Gascuel (2008). DOI: 10.1093/molbev/msn067\n\nReturns\n\nVector{Float64}: Vector of 20 equilibrium frequencies\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.load_lg_rates-Tuple{}","page":"Home","title":"EvolutionModels.load_lg_rates","text":"load_lg_rates()\n\nLoad LG substitution rates matrix from LG.dat. Returns a 20√ó20 symmetric matrix of amino acid substitution rates.\n\nCitation\n\nLe & Gascuel (2008). DOI: 10.1093/molbev/msn067\n\nReturns\n\nMatrix{Float64}: 20√ó20 symmetric rate matrix\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.load_wag_frequencies-Tuple{}","page":"Home","title":"EvolutionModels.load_wag_frequencies","text":"load_wag_frequencies()\n\nLoad WAG amino acid frequencies from WAG.dat. Returns equilibrium frequencies in STANDARD_AA order.\n\nCitation\n\nWhelan & Goldman (2001). DOI: 10.1093/oxfordjournals.molbev.a003851\n\nReturns\n\nVector{Float64}: Vector of 20 equilibrium frequencies\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.load_wag_rates-Tuple{}","page":"Home","title":"EvolutionModels.load_wag_rates","text":"load_wag_rates()\n\nLoad WAG substitution rates matrix from WAG.dat. Returns a 20√ó20 symmetric matrix of amino acid substitution rates.\n\nCitation\n\nWhelan & Goldman (2001). DOI: 10.1093/oxfordjournals.molbev.a003851\n\nReturns\n\nMatrix{Float64}: 20√ó20 symmetric rate matrix\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.normalize_rate_matrix!-Tuple{Matrix{Float64}, Vector{Float64}}","page":"Home","title":"EvolutionModels.normalize_rate_matrix!","text":"normalize_rate_matrix!(Q::Matrix{Float64}, œÄ::Vector{Float64})\n\nNormalize the rate matrix Q in-place so that the expected number of  substitutions per unit time equals 1.\n\nThe normalization factor is Œ≤ = -‚àë·µ¢ œÄ·µ¢ Q·µ¢·µ¢, and Q is divided by Œ≤.\n\nArguments\n\nQ::Matrix{Float64}: Rate matrix to normalize (modified in-place)\nœÄ::Vector{Float64}: Stationary frequencies\n\nReturns\n\nFloat64: The normalization factor Œ≤ used\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.rate_matrix-Tuple{Model}","page":"Home","title":"EvolutionModels.rate_matrix","text":"Get the rate matrix R (includes Œº scaling).\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.sequence_likelihood-Tuple{Model, Union{BioSequences.LongAA, BioSequences.LongDNA{4}, BioSequences.LongNuc{4, BioSequences.DNAAlphabet{4}}}, Union{BioSequences.LongAA, BioSequences.LongDNA{4}, BioSequences.LongNuc{4, BioSequences.DNAAlphabet{4}}}, Float64}","page":"Home","title":"EvolutionModels.sequence_likelihood","text":"sequence_likelihood(model::Model, seq1::Union{LongDNA{4},LongAA}, \n                   seq2::Union{LongDNA{4},LongAA}, t::Float64;\n                   joint::Bool=false) -> Float64\n\nCompute the log-probability of observing two sequences separated by evolutionary  time t under the given model.\n\nConditional likelihood (default, joint=false):\n\nlog P(textseq2  textseq1 t) = sum_i log P(t)_x_1i x_2i\n\nJoint likelihood (joint=true):\n\nlog P(textseq1 textseq2  t) = sum_i left log pi_x_1i + log P(t)_x_1i x_2i right\n\nwhere P(t) = exp(Qt) is the transition probability matrix, œÄ is the stationary  distribution, and x‚ÇÅ·µ¢, x‚ÇÇ·µ¢ are states at position i.\n\nArguments\n\nmodel::Model: Evolution model (DNA or protein)\nseq1::Union{LongDNA{4},LongAA}: First sequence  \nseq2::Union{LongDNA{4},LongAA}: Second sequence\nt::Float64: Evolution time (branch length) between sequences\njoint::Bool=false: If true, compute joint likelihood including œÄ terms\n\nReturns\n\nFloat64: Log-probability (conditional or joint)\n\nExample\n\nmodel = create_model(LGModel, 1.0, normalize=true)\nseq1 = aa\"EVQLVES\"\nseq2 = aa\"EVQLIES\"\n\n# Conditional: P(seq2 | seq1, t) - use for ML distance estimation\nL_cond = sequence_likelihood(model, seq1, seq2, 0.1)\n\n# Joint: P(seq1, seq2 | t) - use for model comparison\nL_joint = sequence_likelihood(model, seq1, seq2, 0.1, joint=true)\n\nWhen to use each\n\nConditional (joint=false): ML distance estimation (œÄ doesn't affect argmax over t)\nJoint (joint=true): Model comparison, Bayesian inference, proper likelihood values\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.stationary_frequencies-Tuple{Model}","page":"Home","title":"EvolutionModels.stationary_frequencies","text":"Get the stationary distribution œÄ.\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.symbol_index-Tuple{BioSymbols.DNA, DNAType}","page":"Home","title":"EvolutionModels.symbol_index","text":"Get index of a symbol in the canonical ordering\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.transition_probability_matrix-Tuple{Model, Float64}","page":"Home","title":"EvolutionModels.transition_probability_matrix","text":"Compute transition probability matrix P(t) = exp(Qt).\n\n\n\n\n\n","category":"method"},{"location":"#EvolutionModels.validate_frequencies-Union{Tuple{S}, Tuple{Vector{Float64}, S}} where S<:SequenceType","page":"Home","title":"EvolutionModels.validate_frequencies","text":"Validate frequencies vector\n\n\n\n\n\n","category":"method"}]
}
